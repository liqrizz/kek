{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/polygon-clipping/dist/polygon-clipping.js","webpack:///./src/PaintPolygon.css?9718","webpack:///./src/PaintPolygon.css","webpack:///./node_modules/css-loader/lib/url/escape.js","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./src/PaintPolygon.svg","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./node_modules/turf/src/helpers/index.js","webpack:///./node_modules/turf/src/invariant/index.js","webpack:///./node_modules/turf/src/destination/index.js","webpack:///./node_modules/turf/src/circle/index.js","webpack:///./node_modules/turf/src/meta/index.js","webpack:///./src/myTurf.js","webpack:///./node_modules/turf/src/union/index.js","webpack:///./node_modules/turf/src/difference/index.js","webpack:///./src/PaintPolygon.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","factory","self","eval","__webpack_exports__","content","options","transform","undefined","locals","escape","push","url","test","slice","replace","useSourceMap","list","toString","this","map","item","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","sources","source","sourceRoot","concat","join","cssWithMappingToString","mediaQuery","alreadyImportedModules","length","id","fn","memo","stylesInDom","isOldIE","window","document","all","atob","apply","arguments","getTarget","target","querySelector","getElement","styleTarget","HTMLIFrameElement","contentDocument","head","e","singleton","singletonCounter","stylesInsertedAtTop","fixUrls","addStylesToDom","styles","domStyle","refs","j","parts","addStyle","listToStyles","newStyles","base","part","css","media","insertStyleElement","style","insertInto","Error","lastStyleElementInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","before","removeStyleElement","parentNode","removeChild","idx","indexOf","splice","createStyleElement","createElement","attrs","type","addAttrs","el","keys","forEach","setAttribute","obj","update","remove","result","styleIndex","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","link","rel","createLinkElement","updateLink","href","applyToTag","newObj","DEBUG","newList","mayRemove","textStore","replaceText","index","replacement","filter","Boolean","styleSheet","cssText","cssNode","createTextNode","childNodes","autoFixUrls","convertToAbsoluteUrls","blob","oldSrc","location","baseUrl","protocol","host","currentDir","pathname","fullMatch","origUrl","newUrl","unquotedOrigUrl","trim","$1","factors","centimeters","earthRadius","centimetres","degrees","Math","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","geometry","properties","feat","checkIfOptionsExist","bbox","point","coordinates","polygon","ring","multiPolygon","lengthToRadians","distance","units","factor","radiansToDegrees","degreesToRadians","isObject","input","constructor","getGeom","geojson","destination","origin","bearing","coordinates1","coord","Array","isArray","getCoord","longitude1","latitude1","bearingRad","latitude2","asin","sin","cos","atan2","center","radius","steps","geomEach","callback","g","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","features","geometries","circle","union","fc","args","geom","contour","unioned","difference","polygon1","polygon2","geom1","geom2","differenced","L","Control","extend","position","minRadius","maxRadius","layerOptions","drawOptions","weight","eraseOptions","color","menu","drawErase","size","eraseAll","_latlng","_metersPerPixel","onAdd","_map","setRadius","DomUtil","_container","_createMenu","onRemove","off","_onMouseMove","_radius","_circle","startDraw","_action","_addMouseListener","circleMarker","addTo","console","log","startErase","_removeMouseListener","getLayer","_layer","setData","data","_data","group","geoJSON","groupEnd","getData","_iconDraw","_iconErase","DomEvent","on","_clickDraw","_clickErase","_iconSize","_menu","disableClickPropagation","menuContent","cursor","min","max","_cursorMove","_clickSize","_iconEraseAll","_clickEraseAll","evt","_resetMenu","_activeIconStyle","hasClass","_closeMenu","_openMenu","removeClass","icon","addClass","valueAsNumber","_onMouseDown","_onMouseUp","dragging","disable","_mousedown","enable","_stack","_setLatLng","latlng","_stackEvt","getZoom","setLatLng","_latLngAsGeoJSON","lng","lat","_getCircleAsPolygon","zoom","abs","pow","_draw","_erase","action","_processStack","_processingStack","shift","PaintPolygon","control","paintPolygon"],"mappings":"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","file":"Leaflet.PaintPolygon.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"polygon-clipping\"] = factory();\n\telse\n\t\troot[\"polygon-clipping\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./main.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./main.js\":\n/*!*****************!*\\\n  !*** ./main.js ***!\n  \\*****************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.difference = exports.xor = exports.intersection = exports.union = undefined;\\n\\nvar _src = __webpack_require__(/*! ./src */ \\\"./src/index.js\\\");\\n\\nvar _src2 = _interopRequireDefault(_src);\\n\\nvar _operation = __webpack_require__(/*! ./src/operation */ \\\"./src/operation.js\\\");\\n\\nvar _operation2 = _interopRequireDefault(_operation);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nvar union = exports.union = function union(geom) {\\n  for (var _len = arguments.length, moreGeoms = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    moreGeoms[_key - 1] = arguments[_key];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.UNION, geom, moreGeoms);\\n};\\n\\nvar intersection = exports.intersection = function intersection(geom) {\\n  for (var _len2 = arguments.length, moreGeoms = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n    moreGeoms[_key2 - 1] = arguments[_key2];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.INTERSECTION, geom, moreGeoms);\\n};\\n\\nvar xor = exports.xor = function xor(geom) {\\n  for (var _len3 = arguments.length, moreGeoms = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\\n    moreGeoms[_key3 - 1] = arguments[_key3];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.XOR, geom, moreGeoms);\\n};\\n\\nvar difference = exports.difference = function difference(subjectGeom) {\\n  for (var _len4 = arguments.length, clippingGeoms = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\\n    clippingGeoms[_key4 - 1] = arguments[_key4];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.DIFFERENCE, subjectGeom, clippingGeoms);\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./main.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/qheap/index.js\":\n/*!*************************************!*\\\n  !*** ./node_modules/qheap/index.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"module.exports = __webpack_require__(/*! ./lib/qheap.js */ \\\"./node_modules/qheap/lib/qheap.js\\\");\\n\\n\\n//# sourceURL=webpack://polygon-clipping/./node_modules/qheap/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/qheap/lib/qheap.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/qheap/lib/qheap.js ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/**\\n * nodejs heap, classic array implementation\\n *\\n * Items are stored in a balanced binary tree packed into an array where\\n * node is at [i], left child is at [2*i], right at [2*i+1].  Root is at [1].\\n *\\n * Copyright (C) 2014-2017 Andras Radics\\n * Licensed under the Apache License, Version 2.0\\n */\\n\\n\\n\\nmodule.exports = Heap;\\n\\nfunction isBeforeDefault( a, b ) { return a < b; }\\n\\nfunction Heap( opts ) {\\n    opts = opts || {};\\n    if (typeof opts === 'function') opts = {compar: opts};\\n\\n    if (opts.compar) {\\n        this._isBefore = function(a, b) { return opts.compar(a,b) < 0 };\\n    } else if (opts.comparBefore) {\\n        this._isBefore = opts.comparBefore;\\n    } else {\\n        this._isBefore = isBeforeDefault;\\n    }\\n    this.length = 0;\\n    this._freeSpace = opts.freeSpace ? this._trimArraySize : false;\\n    this._list = new Array(opts.size || 100);\\n}\\n\\nHeap.prototype._list = null;\\nHeap.prototype._compar = null;\\nHeap.prototype._isBefore = null;\\nHeap.prototype._freeSpace = null;\\nHeap.prototype.length = 0;\\n\\n/*\\n * insert new item at end, and bubble up\\n */\\nHeap.prototype.insert = function Heap_insert( item ) {\\n    var idx = ++this.length;\\n    var list = this._list;\\n    list[idx] = item;\\n\\n    while (idx > 1) {\\n        var parentidx = idx >> 1;\\n        var parentval = list[parentidx];\\n        if (!(this._isBefore(item, parentval))) break;\\n        list[idx] = parentval;\\n        idx = parentidx;\\n    }\\n    list[idx] = item;\\n};\\nHeap.prototype.append = Heap.prototype.insert;\\nHeap.prototype.push = Heap.prototype.insert;\\nHeap.prototype.unshift = Heap.prototype.insert;\\nHeap.prototype.enqueue = Heap.prototype.insert;\\n\\nHeap.prototype.peek = function Heap_peek( ) {\\n    return this.length > 0 ? this._list[1] : undefined;\\n};\\n\\nHeap.prototype.size = function Heap_size( ) {\\n    return this.length;\\n};\\n\\n/*\\n * return the root, and bubble down last item from top root position\\n * when bubbling down, r: root idx, c: child sub-tree root idx, cv: child root value\\n * Note that the child at (c == this.length) does not have to be tested in the loop,\\n * since its value is the one being bubbled down, so can loop `while (c < len)`.\\n *\\n * Note that a redundant (c < len &&) test before the c vs c+1 compar lets node v0.10\\n * run 4x faster; v4, v5 and v6 run faster without it if using _isBefore and not\\n * raw _compar.\\n *\\n * Note that this version runs faster than the two-pass pull-up-new-root then\\n * bubble-up-last-value-from-hole approach (except when inserting pre-sorted data).\\n */\\nHeap.prototype.remove = function Heap_remove( ) {\\n    if (this.length < 1) return undefined;\\n    var ret = this._list[1];\\n    var itm = this._list[this.length];\\n\\n    var r = 1, c = 2, cv;\\n    var len = this.length;\\n    while (c < len) {\\n        cv = this._list[c];\\n        if (this._isBefore(this._list[c+1], cv)) { cv = this._list[c+1] ; c = c+1 }\\n        if (!(this._isBefore(cv, itm))) break;\\n        this._list[r] = cv;\\n        r = c;\\n        c = c << 1;\\n    }\\n    this._list[len] = 0;\\n    this.length = --len;\\n    if (len) this._list[r] = itm;\\n    if (this._freeSpace) this._freeSpace(this._list, len);\\n\\n    return ret;\\n};\\nHeap.prototype.shift = Heap.prototype.remove;\\nHeap.prototype.pop = Heap.prototype.remove;\\nHeap.prototype.dequeue = Heap.prototype.remove;\\n\\n/*\\n * Free unused storage slots in the _list.\\n * The default is to unconditionally gc, use the options to omit when not useful.\\n */\\nHeap.prototype.gc = function Heap_gc( options ) {\\n    if (!options) options = {};\\n\\n    var minListLength = options.minLength;      // smallest list that will be gc-d\\n    if (minListLength === undefined) minListLength = 0;\\n\\n    var minListFull = options.minFull;          // list utilization below which to gc\\n    if (minListFull === undefined) minListFull = 1.00;\\n\\n    if (this._list.length >= minListLength && (this.length < this._list.length * minListFull)) {\\n        // gc reallocates the array to free the unused storage slots at the end\\n        // use splice to actually free memory; 7% slower than setting .length\\n        // note: list.slice makes the array slower to insert to??  splice is better\\n        this._list.splice(this.length+1, this._list.length);\\n    }\\n}\\n\\nHeap.prototype._trimArraySize = function Heap__trimArraySize( list, len ) {\\n    if (len > 10000 && list.length > 4 * len) {\\n        // use slice to actually free memory; 7% slower than setting .length\\n        // note: list.slice makes the array slower to insert to??  splice is better\\n        list.splice(len+1, list.length);\\n    }\\n}\\n\\nHeap.prototype._check = function Heap__check( ) {\\n    var isBefore = this._isBefore;\\n    var _compar = function(a, b) { return isBefore(a, b) ? -1 : 1 };\\n\\n    var i, p, fail = 0;\\n    for (i=this.length; i>1; i--) {\\n        // error if parent should go after child, but not if don`t care\\n        p = i >>> 1;\\n        // swapping the values must change their ordering, otherwise the\\n        // comparison is a tie.  (Ie, consider the ordering func (a <= b)\\n        // that for some values reports both that a < b and b < a.)\\n        if (_compar(this._list[p], this._list[i]) > 0 &&\\n            _compar(this._list[i], this._list[p]) < 0)\\n        {\\n            fail = i;\\n        }\\n    }\\n    if (fail) console.log(\\\"failed at\\\", (fail >>> 1), fail);\\n    return !fail;\\n}\\n\\n// optimize access\\nHeap.prototype = Heap.prototype;\\n\\n\\n//# sourceURL=webpack://polygon-clipping/./node_modules/qheap/lib/qheap.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/splaytree/index.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/splaytree/index.js ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"default\\\", function() { return Tree; });\\n/* follows \\\"An implementation of top-down splaying\\\"\\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\\n */\\n\\n/**\\n * @typedef {*} Key\\n */\\n\\n\\n/**\\n * @typedef {*} Value\\n */\\n\\n\\n/**\\n * @typedef {function(node:Node):void} Visitor\\n */\\n\\n\\n/**\\n * @typedef {function(a:Key, b:Key):number} Comparator\\n */\\n\\n\\n/**\\n * @param {function(node:Node):string} NodePrinter\\n */\\n\\n\\n/**\\n * @typedef {Object}  Node\\n * @property {Key}    Key\\n * @property {Value=} data\\n * @property {Node}   left\\n * @property {Node}   right\\n */\\n\\nclass Node {\\n\\n  constructor (key, data) {\\n    this.key    = key;\\n    this.data   = data;\\n    this.left   = null;\\n    this.right  = null;\\n  }\\n}\\n\\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\\n\\n\\n/**\\n * Simple top down splay, not requiring i to be in the tree t.\\n * @param {Key} i\\n * @param {Node?} t\\n * @param {Comparator} comparator\\n */\\nfunction splay (i, t, comparator) {\\n  if (t === null) return t;\\n  let l, r, y;\\n  const N = new Node();\\n  l = r = N;\\n\\n  while (true) {\\n    const cmp = comparator(i, t.key);\\n    //if (i < t.key) {\\n    if (cmp < 0) {\\n      if (t.left === null) break;\\n      //if (i < t.left.key) {\\n      if (comparator(i, t.left.key) < 0) {\\n        y = t.left;                           /* rotate right */\\n        t.left = y.right;\\n        y.right = t;\\n        t = y;\\n        if (t.left === null) break;\\n      }\\n      r.left = t;                               /* link right */\\n      r = t;\\n      t = t.left;\\n    //} else if (i > t.key) {\\n    } else if (cmp > 0) {\\n      if (t.right === null) break;\\n      //if (i > t.right.key) {\\n      if (comparator(i, t.right.key) > 0) {\\n        y = t.right;                          /* rotate left */\\n        t.right = y.left;\\n        y.left = t;\\n        t = y;\\n        if (t.right === null) break;\\n      }\\n      l.right = t;                              /* link left */\\n      l = t;\\n      t = t.right;\\n    } else {\\n      break;\\n    }\\n  }\\n  /* assemble */\\n  l.right = t.left;\\n  r.left = t.right;\\n  t.left = N.right;\\n  t.right = N.left;\\n  return t;\\n}\\n\\n\\n/**\\n * @param  {Key}        i\\n * @param  {Value}      data\\n * @param  {Comparator} comparator\\n * @param  {Tree}       tree\\n * @return {Node}      root\\n */\\nfunction insert (i, data, t, comparator, tree) {\\n  const node = new Node(i, data);\\n\\n  tree._size++;\\n\\n  if (t === null) {\\n    node.left = node.right = null;\\n    return node;\\n  }\\n\\n  t = splay(i, t, comparator);\\n  const cmp = comparator(i, t.key);\\n  if (cmp < 0) {\\n    node.left = t.left;\\n    node.right = t;\\n    t.left = null;\\n  } else if (cmp >= 0) {\\n    node.right = t.right;\\n    node.left = t;\\n    t.right = null;\\n  }\\n  return node;\\n}\\n\\n\\n/**\\n * Insert i into the tree t, unless it's already there.\\n * @param  {Key}        i\\n * @param  {Value}      data\\n * @param  {Comparator} comparator\\n * @param  {Tree}       tree\\n * @return {Node}       root\\n */\\nfunction add (i, data, t, comparator, tree) {\\n  const node = new Node(i, data);\\n\\n  if (t === null) {\\n    node.left = node.right = null;\\n    tree._size++;\\n    return node;\\n  }\\n\\n  t = splay(i, t, comparator);\\n  const cmp = comparator(i, t.key);\\n  if (cmp === 0) return t;\\n  else {\\n    if (cmp < 0) {\\n      node.left = t.left;\\n      node.right = t;\\n      t.left = null;\\n    } else if (cmp > 0) {\\n      node.right = t.right;\\n      node.left = t;\\n      t.right = null;\\n    }\\n    tree._size++;\\n    return node;\\n  }\\n}\\n\\n\\n/**\\n * Deletes i from the tree if it's there\\n * @param {Key}        i\\n * @param {Tree}       tree\\n * @param {Comparator} comparator\\n * @param {Tree}       tree\\n * @return {Node}      new root\\n */\\nfunction remove (i, t, comparator, tree) {\\n  let x;\\n  if (t === null) return null;\\n  t = splay(i, t, comparator);\\n  if (i === t.key) {               /* found it */\\n    if (t.left === null) {\\n      x = t.right;\\n    } else {\\n      x = splay(i, t.left, comparator);\\n      x.right = t.right;\\n    }\\n    tree._size--;\\n    return x;\\n  }\\n  return t;                         /* It wasn't there */\\n}\\n\\n\\nfunction split (key, v, comparator) {\\n  let left, right;\\n  if (v === null) {\\n    left = right = null;\\n  } else {\\n    v = splay(key, v, comparator);\\n\\n    const cmp = comparator(v.key, key);\\n    if (cmp === 0) {\\n      left  = v.left;\\n      right = v.right;\\n    } else if (cmp < 0) {\\n      right   = v.right;\\n      v.right = null;\\n      left    = v;\\n    } else {\\n      left   = v.left;\\n      v.left = null;\\n      right  = v;\\n    }\\n  }\\n  return { left, right };\\n}\\n\\n\\nfunction merge (left, right, comparator) {\\n  if (right === null) return left;\\n  if (left  === null) return right;\\n\\n  right = splay(left.key, right, comparator);\\n  right.left = left;\\n  return right;\\n}\\n\\n\\n/**\\n * Prints level of the tree\\n * @param  {Node}                        root\\n * @param  {String}                      prefix\\n * @param  {Boolean}                     isTail\\n * @param  {Array<string>}               out\\n * @param  {Function(node:Node):String}  printNode\\n */\\nfunction printRow (root, prefix, isTail, out, printNode) {\\n  if (root) {\\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\\\n`);\\n    const indent = prefix + (isTail ? '    ' : '│   ');\\n    if (root.left)  printRow(root.left,  indent, false, out, printNode);\\n    if (root.right) printRow(root.right, indent, true,  out, printNode);\\n  }\\n}\\n\\n\\nclass Tree {\\n\\n  constructor (comparator = DEFAULT_COMPARE) {\\n    this._comparator = comparator;\\n    this._root = null;\\n    this._size = 0;\\n  }\\n\\n\\n  /**\\n   * Inserts a key, allows duplicates\\n   * @param  {Key}    key\\n   * @param  {Value=} data\\n   * @return {Node|null}\\n   */\\n  insert (key, data) {\\n    return this._root = insert(key, data, this._root, this._comparator, this);\\n  }\\n\\n\\n  /**\\n   * Adds a key, if it is not present in the tree\\n   * @param  {Key}    key\\n   * @param  {Value=} data\\n   * @return {Node|null}\\n   */\\n  add (key, data) {\\n    return this._root = add(key, data, this._root, this._comparator, this);\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Node|null}\\n   */\\n  remove (key) {\\n    this._root = remove(key, this._root, this._comparator, this);\\n  }\\n\\n\\n  /**\\n   * Removes and returns the node with smallest key\\n   * @return {?Node}\\n   */\\n  pop () {\\n    let node = this._root;\\n    if (node) {\\n      while (node.left) node = node.left;\\n      this._root = splay(node.key,  this._root, this._comparator);\\n      this._root = remove(node.key, this._root, this._comparator, this);\\n      return { key: node.key, data: node.data };\\n    }\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Node|null}\\n   */\\n  findStatic (key) {\\n    let current   = this._root;\\n    const compare = this._comparator;\\n    while (current) {\\n      const cmp = compare(key, current.key);\\n      if (cmp === 0)    return current;\\n      else if (cmp < 0) current = current.left;\\n      else              current = current.right;\\n    }\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Node|null}\\n   */\\n  find (key) {\\n    if (this._root) {\\n      this._root = splay(key, this._root, this._comparator);\\n      if (this._comparator(key, this._root.key) !== 0) return null;\\n    }\\n    return this._root;\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Boolean}\\n   */\\n  contains (key) {\\n    let current   = this._root;\\n    const compare = this._comparator;\\n    while (current) {\\n      const cmp = compare(key, current.key);\\n      if (cmp === 0)    return true;\\n      else if (cmp < 0) current = current.left;\\n      else              current = current.right;\\n    }\\n    return false;\\n  }\\n\\n\\n  /**\\n   * @param  {Visitor} visitor\\n   * @param  {*=}      ctx\\n   * @return {SplayTree}\\n   */\\n  forEach (visitor, ctx) {\\n    let current = this._root;\\n    const Q = [];  /* Initialize stack s */\\n    let done = false;\\n\\n    while (!done) {\\n      if (current !==  null) {\\n        Q.push(current);\\n        current = current.left;\\n      } else {\\n        if (Q.length !== 0) {\\n          current = Q.pop();\\n          visitor.call(ctx, current);\\n\\n          current = current.right;\\n        } else done = true;\\n      }\\n    }\\n    return this;\\n  }\\n\\n\\n  /**\\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\\n   * @param  {Key}      low\\n   * @param  {Key}      high\\n   * @param  {Function} fn\\n   * @param  {*?}       ctx\\n   * @return {SplayTree}\\n   */\\n  range (low, high, fn, ctx) {\\n    const Q = [];\\n    const compare = this._comparator;\\n    let node = this._root, cmp;\\n\\n    while (Q.length !== 0 || node) {\\n      if (node) {\\n        Q.push(node);\\n        node = node.left;\\n      } else {\\n        node = Q.pop();\\n        cmp = compare(node.key, high);\\n        if (cmp > 0) {\\n          break;\\n        } else if (compare(node.key, low) >= 0) {\\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\\n        }\\n        node = node.right;\\n      }\\n    }\\n    return this;\\n  }\\n\\n\\n  /**\\n   * Returns array of keys\\n   * @return {Array<Key>}\\n   */\\n  keys () {\\n    const keys = [];\\n    this.forEach(({ key }) => keys.push(key));\\n    return keys;\\n  }\\n\\n\\n  /**\\n   * Returns array of all the data in the nodes\\n   * @return {Array<Value>}\\n   */\\n  values () {\\n    const values = [];\\n    this.forEach(({ data }) => values.push(data));\\n    return values;\\n  }\\n\\n\\n  /**\\n   * @return {Key|null}\\n   */\\n  min() {\\n    if (this._root) return this.minNode(this._root).key;\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @return {Key|null}\\n   */\\n  max() {\\n    if (this._root) return this.maxNode(this._root).key;\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @return {Node|null}\\n   */\\n  minNode(t = this._root) {\\n    if (t) while (t.left) t = t.left;\\n    return t;\\n  }\\n\\n\\n  /**\\n   * @return {Node|null}\\n   */\\n  maxNode(t = this._root) {\\n    if (t) while (t.right) t = t.right;\\n    return t;\\n  }\\n\\n\\n  /**\\n   * Returns node at given index\\n   * @param  {number} index\\n   * @return {?Node}\\n   */\\n  at (index) {\\n    let current = this._root, done = false, i = 0;\\n    const Q = [];\\n\\n    while (!done) {\\n      if (current) {\\n        Q.push(current);\\n        current = current.left;\\n      } else {\\n        if (Q.length > 0) {\\n          current = Q.pop();\\n          if (i === index) return current;\\n          i++;\\n          current = current.right;\\n        } else done = true;\\n      }\\n    }\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @param  {Node}   d\\n   * @return {Node|null}\\n   */\\n  next (d) {\\n    let root = this._root;\\n    let successor = null;\\n\\n    if (d.right) {\\n      successor = d.right;\\n      while (successor.left) successor = successor.left;\\n      return successor;\\n    }\\n\\n    const comparator = this._comparator;\\n    while (root) {\\n      const cmp = comparator(d.key, root.key);\\n      if (cmp === 0) break;\\n      else if (cmp < 0) {\\n        successor = root;\\n        root = root.left;\\n      } else root = root.right;\\n    }\\n\\n    return successor;\\n  }\\n\\n\\n  /**\\n   * @param  {Node} d\\n   * @return {Node|null}\\n   */\\n  prev (d) {\\n    let root = this._root;\\n    let predecessor = null;\\n\\n    if (d.left !== null) {\\n      predecessor = d.left;\\n      while (predecessor.right) predecessor = predecessor.right;\\n      return predecessor;\\n    }\\n\\n    const comparator = this._comparator;\\n    while (root) {\\n      const cmp = comparator(d.key, root.key);\\n      if (cmp === 0) break;\\n      else if (cmp < 0) root = root.left;\\n      else {\\n        predecessor = root;\\n        root = root.right;\\n      }\\n    }\\n    return predecessor;\\n  }\\n\\n\\n  /**\\n   * @return {SplayTree}\\n   */\\n  clear() {\\n    this._root = null;\\n    this._size = 0;\\n    return this;\\n  }\\n\\n\\n  /**\\n   * @return {NodeList}\\n   */\\n  toList() {\\n    return toList(this._root);\\n  }\\n\\n\\n  /**\\n   * Bulk-load items. Both array have to be same size\\n   * @param  {Array<Key>}    keys\\n   * @param  {Array<Value>}  [values]\\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\\n   *                                         tree's comparator. Sorting is done\\n   *                                         in-place\\n   * @return {AVLTree}\\n   */\\n  load (keys = [], values = [], presort = false) {\\n    let size = keys.length;\\n    const comparator = this._comparator;\\n\\n    // sort if needed\\n    if (presort) sort(keys, values, 0, size - 1, comparator);\\n\\n    if (this._root === null) { // empty tree\\n      this._root = loadRecursive(this._root, keys, values, 0, size);\\n      this._size = size;\\n    } else { // that re-builds the whole tree from two in-order traversals\\n      const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\\n      size = this._size + size;\\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\\n    }\\n    return this;\\n  }\\n\\n\\n  /**\\n   * @return {Boolean}\\n   */\\n  isEmpty() { return this._root === null; }\\n\\n  get size () { return this._size; }\\n\\n\\n  /**\\n   * @param  {NodePrinter=} printNode\\n   * @return {String}\\n   */\\n  toString (printNode = (n) => n.key) {\\n    const out = [];\\n    printRow(this._root, '', true, (v) => out.push(v), printNode);\\n    return out.join('');\\n  }\\n\\n\\n  update (key, newKey, newData) {\\n    const comparator = this._comparator;\\n    let { left, right } = split(key, this._root, comparator);\\n    this._size--;\\n    if (comparator(key, newKey) < 0) {\\n      right = insert(newKey, newData, right, comparator, this);\\n    } else {\\n      left = insert(newKey, newData, left, comparator, this);\\n    }\\n    this._root = merge(left, right, comparator);\\n  }\\n\\n\\n  split(key) {\\n    return split(key, this._root, this._comparator);\\n  }\\n}\\n\\n\\nfunction loadRecursive (parent, keys, values, start, end) {\\n  const size = end - start;\\n  if (size > 0) {\\n    const middle = start + Math.floor(size / 2);\\n    const key    = keys[middle];\\n    const data   = values[middle];\\n    const node   = { key, data, parent };\\n    node.left    = loadRecursive(node, keys, values, start, middle);\\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\\n    return node;\\n  }\\n  return null;\\n}\\n\\n\\nfunction createList(keys, values) {\\n  const head = { next: null };\\n  let p = head;\\n  for (let i = 0; i < keys.length; i++) {\\n    p = p.next = { key: keys[i], data: values[i] };\\n  }\\n  p.next = null;\\n  return head.next;\\n}\\n\\n\\nfunction toList (root) {\\n  var current = root;\\n  var Q = [], done = false;\\n\\n  const head = { next: null };\\n  let p = head;\\n\\n  while (!done) {\\n    if (current) {\\n      Q.push(current);\\n      current = current.left;\\n    } else {\\n      if (Q.length > 0) {\\n        current = p = p.next = Q.pop();\\n        current = current.right;\\n      } else done = true;\\n    }\\n  }\\n  p.next = null; // that'll work even if the tree was empty\\n  return head.next;\\n}\\n\\n\\nfunction sortedListToBST(list, start, end) {\\n  const size = end - start;\\n  if (size > 0) {\\n    const middle = start + Math.floor(size / 2);\\n    const left = sortedListToBST(list, start, middle);\\n\\n    const root = list.head;\\n    root.left = left;\\n\\n    list.head = list.head.next;\\n\\n    root.right = sortedListToBST(list, middle + 1, end);\\n    return root;\\n  }\\n  return null;\\n}\\n\\n\\nfunction mergeLists (l1, l2, compare = (a, b) => a - b) {\\n  const head = {}; // dummy\\n  let p = head;\\n\\n  let p1 = l1;\\n  let p2 = l2;\\n\\n  while (p1 !== null && p2 !== null) {\\n    if (compare(p1.key, p2.key) < 0) {\\n      p.next = p1;\\n      p1 = p1.next;\\n    } else {\\n      p.next = p2;\\n      p2 = p2.next;\\n    }\\n    p = p.next;\\n  }\\n\\n  if (p1 !== null)      p.next = p1;\\n  else if (p2 !== null) p.next = p2;\\n\\n  return head.next;\\n}\\n\\n\\nfunction sort(keys, values, left, right, compare) {\\n  if (left >= right) return;\\n\\n  const pivot = keys[(left + right) >> 1];\\n  let i = left - 1;\\n  let j = right + 1;\\n\\n  while (true) {\\n    do i++; while (compare(keys[i], pivot) < 0);\\n    do j--; while (compare(keys[j], pivot) > 0);\\n    if (i >= j) break;\\n\\n    let tmp = keys[i];\\n    keys[i] = keys[j];\\n    keys[j] = tmp;\\n\\n    tmp = values[i];\\n    values[i] = values[j];\\n    values[j] = tmp;\\n  }\\n\\n  sort(keys, values,  left,     j, compare);\\n  sort(keys, values, j + 1, right, compare);\\n}\\n\\n\\n//# sourceURL=webpack://polygon-clipping/./node_modules/splaytree/index.js?\");\n\n/***/ }),\n\n/***/ \"./src/bbox.js\":\n/*!*********************!*\\\n  !*** ./src/bbox.js ***!\n  \\*********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getUniqueCorners = exports.getBboxOverlap = exports.doBboxesOverlap = exports.isInBbox = undefined;\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\n/**\\n * A bounding box has the format:\\n *\\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\\n *\\n */\\n\\nvar isInBbox = exports.isInBbox = function isInBbox(bbox, point) {\\n  var xmin = bbox.ll.x;\\n  var ymin = bbox.ll.y;\\n  var xmax = bbox.ur.x;\\n  var ymax = bbox.ur.y;\\n  var xpt = point.x;\\n  var ypt = point.y;\\n  return (0, _flp.cmp)(xmin, xpt) <= 0 && (0, _flp.cmp)(xpt, xmax) <= 0 && (0, _flp.cmp)(ymin, ypt) <= 0 && (0, _flp.cmp)(ypt, ymax) <= 0;\\n};\\n\\nvar doBboxesOverlap = exports.doBboxesOverlap = function doBboxesOverlap(b1, b2) {\\n  return !((0, _flp.cmp)(b2.ur.x, b1.ll.x) < 0 || (0, _flp.cmp)(b1.ur.x, b2.ll.x) < 0 || (0, _flp.cmp)(b2.ur.y, b1.ll.y) < 0 || (0, _flp.cmp)(b1.ur.y, b2.ll.y) < 0);\\n};\\n\\n/* Returns either null, or a bbox (aka an ordered pair of points)\\n * If there is only one point of overlap, a bbox with identical points\\n * will be returned */\\nvar getBboxOverlap = exports.getBboxOverlap = function getBboxOverlap(b1, b2) {\\n  if (!doBboxesOverlap(b1, b2)) return null;\\n\\n  // find the middle two X values\\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\\n\\n  // find the middle two Y values\\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\\n\\n  // put those middle values together to get the overlap\\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };\\n};\\n\\n/* Returns a list of unique corners.\\n * Will contain one, two or four points */\\nvar getUniqueCorners = exports.getUniqueCorners = function getUniqueCorners(bbox) {\\n  var xmin = bbox.ll.x;\\n  var ymin = bbox.ll.y;\\n  var xmax = bbox.ur.x;\\n  var ymax = bbox.ur.y;\\n  var xEq = (0, _flp.cmp)(xmin, xmax) === 0;\\n  var yEq = (0, _flp.cmp)(ymin, ymax) === 0;\\n  if (xEq && yEq) return [{ x: xmin, y: ymin }];\\n  if (xEq) return [{ x: xmin, y: ymin }, { x: xmin, y: ymax }];\\n  if (yEq) return [{ x: xmin, y: ymin }, { x: xmax, y: ymin }];\\n  return [{ x: xmin, y: ymin }, { x: xmin, y: ymax }, { x: xmax, y: ymin }, { x: xmax, y: ymax }];\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/bbox.js?\");\n\n/***/ }),\n\n/***/ \"./src/clean-input.js\":\n/*!****************************!*\\\n  !*** ./src/clean-input.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.errorOnSelfIntersectingRings = exports.cleanRing = exports.cleanMultiPoly = exports.forceMultiPoly = exports.pointsAsObjects = undefined;\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\n/* Given input geometry as a standard array-of-arrays geojson-style\\n * geometry, return one that uses objects as points, for better perf */\\nvar pointsAsObjects = exports.pointsAsObjects = function pointsAsObjects(geom) {\\n  // we can handle well-formed multipolys and polys\\n  var output = [];\\n  if (!Array.isArray(geom)) {\\n    throw new Error('Input is not a Polygon or MultiPolygon');\\n  }\\n  for (var i = 0, iMax = geom.length; i < iMax; i++) {\\n    if (!Array.isArray(geom[i])) {\\n      throw new Error('Input is not a Polygon or MultiPolygon');\\n    }\\n    output.push([]);\\n    for (var j = 0, jMax = geom[i].length; j < jMax; j++) {\\n      if (!Array.isArray(geom[i][j])) {\\n        throw new Error('Input is not a Polygon or MultiPolygon');\\n      }\\n      if (geom[i][j].length === 2) {\\n        output[i].push({ x: geom[i][j][0], y: geom[i][j][1] });\\n        continue;\\n      }\\n      output[i].push([]);\\n      for (var k = 0, kMax = geom[i][j].length; k < kMax; k++) {\\n        if (!Array.isArray(geom[i][j][k]) || geom[i][j][k].length !== 2) {\\n          throw new Error('Input is not a Polygon or MultiPolygon');\\n        }\\n        output[i][j].push({ x: geom[i][j][k][0], y: geom[i][j][k][1] });\\n      }\\n    }\\n  }\\n  return output;\\n};\\n\\n/* WARN: input modified directly */\\nvar forceMultiPoly = exports.forceMultiPoly = function forceMultiPoly(geom) {\\n  if (Array.isArray(geom)) {\\n    if (geom.length === 0) return; // allow empty multipolys\\n\\n    if (Array.isArray(geom[0])) {\\n      if (Array.isArray(geom[0][0])) {\\n        if (typeof geom[0][0][0].x === 'number' && typeof geom[0][0][0].y === 'number') {\\n          // multipolygon\\n          return;\\n        }\\n      }\\n      if (typeof geom[0][0].x === 'number' && typeof geom[0][0].y === 'number') {\\n        // polygon\\n        geom.unshift(geom.splice(0));\\n        return;\\n      }\\n    }\\n  }\\n  throw new Error('Unrecognized input - not a polygon nor multipolygon');\\n};\\n\\n/* WARN: input modified directly */\\nvar cleanMultiPoly = exports.cleanMultiPoly = function cleanMultiPoly(multipoly) {\\n  var i = 0;\\n  while (i < multipoly.length) {\\n    var poly = multipoly[i];\\n    if (poly.length === 0) {\\n      multipoly.splice(i, 1);\\n      continue;\\n    }\\n\\n    var exteriorRing = poly[0];\\n    cleanRing(exteriorRing);\\n    // poly is dropped if exteriorRing is degenerate\\n    if (exteriorRing.length === 0) {\\n      multipoly.splice(i, 1);\\n      continue;\\n    }\\n\\n    var j = 1;\\n    while (j < poly.length) {\\n      var interiorRing = poly[j];\\n      cleanRing(interiorRing);\\n      if (interiorRing.length === 0) poly.splice(j, 1);else j++;\\n    }\\n\\n    i++;\\n  }\\n};\\n\\n/* Clean ring:\\n *  - remove duplicate points\\n *  - remove colinear points\\n *  - remove rings with no area (less than 3 distinct points)\\n *  - close rings (last point should equal first)\\n *\\n * WARN: input modified directly */\\nvar cleanRing = exports.cleanRing = function cleanRing(ring) {\\n  if (ring.length === 0) return;\\n  if ((0, _flp.cmpPoints)(ring[0], ring[ring.length - 1]) !== 0) {\\n    ring.push({ x: ring[0].x, y: ring[0].y }); // copy by value\\n  }\\n\\n  var isPointUncessary = function isPointUncessary(prevPt, pt, nextPt) {\\n    return (0, _flp.cmpPoints)(prevPt, pt) === 0 || (0, _flp.cmpPoints)(pt, nextPt) === 0 || (0, _vector.compareVectorAngles)(pt, prevPt, nextPt) === 0;\\n  };\\n\\n  var i = 1;\\n  while (i < ring.length - 1) {\\n    if (isPointUncessary(ring[i - 1], ring[i], ring[i + 1])) ring.splice(i, 1);else i++;\\n  }\\n\\n  // check the first/last point as well\\n  while (ring.length > 2) {\\n    if (!isPointUncessary(ring[ring.length - 2], ring[0], ring[1])) break;\\n    ring.splice(0, 1);\\n    ring.splice(ring.length - 1, 1);\\n    ring.push(ring[0]);\\n  }\\n\\n  // if our ring has less than 3 distinct points now (so is degenerate)\\n  // shrink it down to the empty array to communicate to our caller to\\n  // drop it\\n  while (ring.length < 4 && ring.length > 0) {\\n    ring.pop();\\n  }\\n};\\n\\n/* Scan the already-linked events of the segments for any\\n * self-intersecting input rings (which are not supported) */\\nvar errorOnSelfIntersectingRings = exports.errorOnSelfIntersectingRings = function errorOnSelfIntersectingRings(segments) {\\n  var _loop = function _loop(i, iMax) {\\n    var seg = segments[i];\\n\\n    var evt = seg.flowIntoSE;\\n\\n    if (evt.linkedEvents.length > 2) {\\n      var evtsThisRing = evt.linkedEvents.filter(function (other) {\\n        return other.segment.ringIn === seg.ringIn;\\n      });\\n      if (evtsThisRing.length > 2) {\\n        evtsThisRing.sort(evt.getLeftmostComparator(evt.otherSE));\\n        var leftMostEvt = evtsThisRing[1]; // skip ourself\\n        var rightMostEvt = evtsThisRing[evtsThisRing.length - 1];\\n\\n        // both the segment on our immediate left and right will flow\\n        // 'out' in intersection point was a touch and not a crossing\\n        if (leftMostEvt.segment.flowIntoSE === leftMostEvt || rightMostEvt.segment.flowIntoSE === rightMostEvt) {\\n          throw new Error('Self-intersecting, crossing input ring found at ' + ('[' + evt.point.x + ', ' + evt.point.y + ']'));\\n        }\\n      }\\n    }\\n  };\\n\\n  for (var i = 0, iMax = segments.length; i < iMax; i++) {\\n    _loop(i, iMax);\\n  }\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/clean-input.js?\");\n\n/***/ }),\n\n/***/ \"./src/flp.js\":\n/*!********************!*\\\n  !*** ./src/flp.js ***!\n  \\********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n/* Javascript doesn't do integer math. Everything is\\n * floating point with percision Number.EPSILON.\\n *\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\\n */\\n\\n// IE Polyfill\\nif (Number.EPSILON === undefined) Number.EPSILON = Math.pow(2, -52);\\n\\nvar EPSILON_SQ = Number.EPSILON * Number.EPSILON;\\n\\n/* FLP comparator */\\nvar cmp = exports.cmp = function cmp(a, b) {\\n  // check if they're both 0\\n  if (-Number.EPSILON < a && a < Number.EPSILON) {\\n    if (-Number.EPSILON < b && b < Number.EPSILON) {\\n      return 0;\\n    }\\n  }\\n\\n  // check if they're flp equal\\n  if ((a - b) * (a - b) < EPSILON_SQ * a * b) {\\n    return 0;\\n  }\\n\\n  // normal comparison\\n  return a < b ? -1 : 1;\\n};\\n\\n/* FLP point comparator, favors point encountered first by sweep line */\\nvar cmpPoints = exports.cmpPoints = function cmpPoints(aPt, bPt) {\\n  // fist compare X, then compare Y\\n\\n  var a = aPt.x;\\n  var b = bPt.x;\\n\\n  // inlined version of cmp() for performance boost\\n  if (a <= -Number.EPSILON || Number.EPSILON <= a || b <= -Number.EPSILON || Number.EPSILON <= b) {\\n    var diff = a - b;\\n    if (diff * diff >= EPSILON_SQ * a * b) {\\n      return a < b ? -1 : 1;\\n    }\\n  }\\n\\n  a = aPt.y;\\n  b = bPt.y;\\n\\n  // inlined version of cmp() for performance boost\\n  if (a <= -Number.EPSILON || Number.EPSILON <= a || b <= -Number.EPSILON || Number.EPSILON <= b) {\\n    var _diff = a - b;\\n    if (_diff * _diff >= EPSILON_SQ * a * b) {\\n      return a < b ? -1 : 1;\\n    }\\n  }\\n\\n  // they're the same\\n  return 0;\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/flp.js?\");\n\n/***/ }),\n\n/***/ \"./src/geom-in.js\":\n/*!************************!*\\\n  !*** ./src/geom-in.js ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MultiPoly = exports.Poly = exports.Ring = undefined;\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _segment = __webpack_require__(/*! ./segment */ \\\"./src/segment.js\\\");\\n\\nvar _segment2 = _interopRequireDefault(_segment);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n// Give rings unique ID's to get consistent sorting of segments\\n// and sweep events when all else is identical\\nvar ringId = 0;\\n\\nvar Ring = exports.Ring = function () {\\n  function Ring(geomRing, poly) {\\n    _classCallCheck(this, Ring);\\n\\n    this.id = ringId++;\\n    this.poly = poly;\\n    this.segments = [];\\n\\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\\n      this.segments.push(new _segment2.default(geomRing[i - 1], geomRing[i], this));\\n    }\\n  }\\n\\n  _createClass(Ring, [{\\n    key: 'getSweepEvents',\\n    value: function getSweepEvents() {\\n      var sweepEvents = [];\\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\\n        var segment = this.segments[i];\\n        sweepEvents.push(segment.leftSE);\\n        sweepEvents.push(segment.rightSE);\\n      }\\n      return sweepEvents;\\n    }\\n  }, {\\n    key: 'isValid',\\n\\n\\n    /* Given a segment on this rings with these relationships to other rings,\\n     * is it a valid segment of the ring's poly? */\\n    value: function isValid(ringsSameSLER, ringsDiffSLER, ringsInsideOf) {\\n      var exterior = this.poly.exteriorRing;\\n      var interiors = this.poly.interiorRings;\\n\\n      if (this === exterior) {\\n        // exterior segments inside or interior, nope\\n        for (var i = 0, iMax = ringsInsideOf.length; i < iMax; i++) {\\n          if (interiors.includes(ringsInsideOf[i])) return false;\\n        }\\n\\n        // overlap with an interior of same SWL orientatio, nope\\n        for (var _i = 0, _iMax = ringsSameSLER.length; _i < _iMax; _i++) {\\n          if (interiors.includes(ringsSameSLER[_i])) return false;\\n        }\\n\\n        return true;\\n      }\\n\\n      // interior rings that aren't inside the exterior nor\\n      // overlapping with different SWE\\n      if (!ringsInsideOf.includes(exterior)) {\\n        if (!ringsDiffSLER.includes(exterior)) return false;\\n      }\\n\\n      // interior rings inside another interior, nope\\n      for (var _i2 = 0, _iMax2 = ringsInsideOf.length; _i2 < _iMax2; _i2++) {\\n        if (interiors.includes(ringsInsideOf[_i2])) return false;\\n      }\\n\\n      // overlapping interiors with different sweep line orientation, nope\\n      for (var _i3 = 0, _iMax3 = ringsDiffSLER.length; _i3 < _iMax3; _i3++) {\\n        if (interiors.includes(ringsDiffSLER[_i3])) return false;\\n      }\\n\\n      return true;\\n    }\\n  }, {\\n    key: 'isExterior',\\n    get: function get() {\\n      return this.poly.exteriorRing === this;\\n    }\\n  }, {\\n    key: 'isInterior',\\n    get: function get() {\\n      return this.poly.exteriorRing !== this;\\n    }\\n  }]);\\n\\n  return Ring;\\n}();\\n\\nvar Poly = exports.Poly = function () {\\n  function Poly(geomPoly, multiPoly) {\\n    _classCallCheck(this, Poly);\\n\\n    this.exteriorRing = new Ring(geomPoly[0], this);\\n    this.interiorRings = [];\\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\\n      this.interiorRings.push(new Ring(geomPoly[i], this));\\n    }\\n    this.multiPoly = multiPoly;\\n  }\\n\\n  _createClass(Poly, [{\\n    key: 'getSweepEvents',\\n    value: function getSweepEvents() {\\n      var sweepEvents = this.exteriorRing.getSweepEvents();\\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\\n          sweepEvents.push(ringSweepEvents[j]);\\n        }\\n      }\\n      return sweepEvents;\\n    }\\n\\n    /* Given a segment with these rings, is that segment inside this polygon? */\\n\\n  }, {\\n    key: 'isInside',\\n    value: function isInside(ringsOnEdgeOf, ringsInsideOf) {\\n      // if we're on an edge, we can't be inside\\n      for (var i = 0, iMax = ringsOnEdgeOf.length; i < iMax; i++) {\\n        if (ringsOnEdgeOf[i].poly === this) return false;\\n      }\\n\\n      // we need to be inside the exterior, and nothing else\\n      var isInsideExterior = false;\\n      for (var _i4 = 0, _iMax4 = ringsInsideOf.length; _i4 < _iMax4; _i4++) {\\n        var ring = ringsInsideOf[_i4];\\n        if (ring.poly !== this) continue;\\n        if (ring.isInterior) return false;\\n        isInsideExterior = true;\\n      }\\n      return isInsideExterior;\\n    }\\n  }]);\\n\\n  return Poly;\\n}();\\n\\nvar MultiPoly = exports.MultiPoly = function () {\\n  function MultiPoly(geomMultiPoly) {\\n    _classCallCheck(this, MultiPoly);\\n\\n    this.polys = [];\\n    for (var i = 0, iMax = geomMultiPoly.length; i < iMax; i++) {\\n      this.polys.push(new Poly(geomMultiPoly[i], this));\\n    }\\n    this.isSubject = false;\\n  }\\n\\n  _createClass(MultiPoly, [{\\n    key: 'markAsSubject',\\n    value: function markAsSubject() {\\n      this.isSubject = true;\\n    }\\n  }, {\\n    key: 'getSweepEvents',\\n    value: function getSweepEvents() {\\n      var sweepEvents = [];\\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\\n        var polySweepEvents = this.polys[i].getSweepEvents();\\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\\n          sweepEvents.push(polySweepEvents[j]);\\n        }\\n      }\\n      return sweepEvents;\\n    }\\n  }]);\\n\\n  return MultiPoly;\\n}();\\n\\n//# sourceURL=webpack://polygon-clipping/./src/geom-in.js?\");\n\n/***/ }),\n\n/***/ \"./src/geom-out.js\":\n/*!*************************!*\\\n  !*** ./src/geom-out.js ***!\n  \\*************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MultiPoly = exports.Poly = exports.Ring = undefined;\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar Ring = exports.Ring = function () {\\n  _createClass(Ring, null, [{\\n    key: 'factory',\\n\\n    /* Given the segments from the sweep line pass, compute & return a series\\n     * of closed rings from all the segments marked to be part of the result */\\n    value: function factory(allSegments) {\\n      var ringsOut = [];\\n\\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\\n        var segment = allSegments[i];\\n        if (!segment.isInResult || segment.ringOut) continue;\\n\\n        var prevEvent = null;\\n        var event = segment.leftSE;\\n        var nextEvent = segment.rightSE;\\n        var events = [event];\\n\\n        var startingLE = event.linkedEvents;\\n        var intersectionLEs = [];\\n\\n        /* Walk the chain of linked events to form a closed ring */\\n        while (true) {\\n          prevEvent = event;\\n          event = nextEvent;\\n          events.push(event);\\n\\n          /* Is the ring complete? */\\n          if (event.linkedEvents === startingLE) break;\\n\\n          while (true) {\\n            var availableLEs = event.getAvailableLinkedEvents();\\n\\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\\n             * part of the algorithm malfunctioned... please file a bug report. */\\n            if (availableLEs.length === 0) {\\n              var firstPt = events[0].point;\\n              var lastPt = events[events.length - 1].point;\\n              throw new Error('Unable to complete output ring starting at [' + firstPt.x + ',' + (' ' + firstPt.y + ']. Last matching segment found ends at ') + (' [' + lastPt.x + ', ' + lastPt.y + '].'));\\n            }\\n\\n            /* Only one way to go, so cotinue on the path */\\n            if (availableLEs.length === 1) {\\n              nextEvent = availableLEs[0].otherSE;\\n              break;\\n            }\\n\\n            /* We must have an intersection. Check for a completed loop */\\n            var indexLE = null;\\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\\n              if (intersectionLEs[j].linkedEvents === event.linkedEvents) {\\n                indexLE = j;\\n                break;\\n              }\\n            }\\n            /* Found a completed loop. Cut that off and make a ring */\\n            if (indexLE !== null) {\\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\\n              var ringEvents = events.splice(intersectionLE.index);\\n              ringEvents.unshift(ringEvents[0].otherSE);\\n              ringsOut.push(new Ring(ringEvents.reverse()));\\n              continue;\\n            }\\n            /* register the intersection */\\n            intersectionLEs.push({\\n              index: events.length,\\n              linkedEvents: event.linkedEvents\\n            });\\n            /* Choose the left-most option to continue the walk */\\n            var comparator = event.getLeftmostComparator(prevEvent);\\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\\n            break;\\n          }\\n        }\\n\\n        ringsOut.push(new Ring(events));\\n      }\\n      return ringsOut;\\n    }\\n  }]);\\n\\n  function Ring(events) {\\n    _classCallCheck(this, Ring);\\n\\n    this.events = events;\\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\\n      events[i].segment.registerRingOut(this);\\n    }\\n    this.poly = null;\\n    this._clearCache();\\n  }\\n\\n  _createClass(Ring, [{\\n    key: 'registerPoly',\\n    value: function registerPoly(poly) {\\n      this.poly = poly;\\n    }\\n  }, {\\n    key: 'getGeom',\\n    value: function getGeom() {\\n      // Remove superfluous points (ie extra points along a straight line),\\n      var points = [[this.events[0].point.x, this.events[0].point.y]];\\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\\n        var _prevPt = this.events[i - 1].point;\\n        var _pt = this.events[i].point;\\n        var _nextPt = this.events[i + 1].point;\\n        if ((0, _vector.compareVectorAngles)(_pt, _prevPt, _nextPt) === 0) continue;\\n        points.push([_pt.x, _pt.y]);\\n      }\\n\\n      // check if the starting point is necessary\\n      var prevPt = this.events[this.events.length - 2].point;\\n      var pt = this.events[0].point;\\n      var nextPt = this.events[1].point;\\n      if ((0, _vector.compareVectorAngles)(pt, prevPt, nextPt) === 0) points.shift();\\n\\n      // ring was all (within rounding error of angle calc) colinear points\\n      if (points.length === 0) return null;\\n\\n      points.push(points[0]);\\n      return this.isExteriorRing ? points : points.reverse();\\n    }\\n  }, {\\n    key: '_clearCache',\\n    value: function _clearCache() {\\n      this._cache = {};\\n    }\\n  }, {\\n    key: '_getCached',\\n    value: function _getCached(propName, calcMethod) {\\n      // if this._cache[something] isn't set, fill it with this._something()\\n      if (this._cache[propName] === undefined) {\\n        this._cache[propName] = this['_' + propName].bind(this)();\\n      }\\n      return this._cache[propName];\\n    }\\n  }, {\\n    key: '_isExteriorRing',\\n    value: function _isExteriorRing() {\\n      if (!this.enclosingRing) return true;\\n      if (!this.enclosingRing.enclosingRing) return false;\\n      // an island in hole is a whole new polygon\\n      return this.enclosingRing.enclosingRing.isExteriorRing;\\n    }\\n\\n    /* Returns the ring that encloses this one, if any */\\n\\n  }, {\\n    key: '_enclosingRing',\\n    value: function _enclosingRing() {\\n      var prevSeg = this.events[0].segment.prevInResult;\\n      while (prevSeg && prevSeg.ringOut === this) {\\n        prevSeg = prevSeg.prevInResult;\\n      }var prevPrevSeg = prevSeg ? prevSeg.prevInResult : null;\\n\\n      while (true) {\\n        // no segment found, thus no ring can enclose us\\n        if (!prevSeg) return null;\\n\\n        // no segments below prev segment found, thus the ring of the prev\\n        // segment must loop back around and enclose us\\n        if (!prevPrevSeg) return prevSeg.ringOut;\\n\\n        // if the two segments are of different rings, the ring of the prev\\n        // segment must either loop around us or the ring of the prev prev\\n        // seg, which would make us and the ring of the prev peers\\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\\n          if (prevPrevSeg.ringOut.enclosingRing !== prevSeg.ringOut) {\\n            return prevSeg.ringOut;\\n          } else return prevSeg.ringOut.enclosingRing;\\n        }\\n\\n        // two segments are from the same ring, so this was a penisula\\n        // of that ring. iterate downward, keep searching\\n        prevSeg = prevPrevSeg.prevInResult;\\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult : null;\\n      }\\n    }\\n  }, {\\n    key: 'enclosingRing',\\n    get: function get() {\\n      return this._getCached('enclosingRing');\\n    }\\n  }, {\\n    key: 'isExteriorRing',\\n    get: function get() {\\n      return this._getCached('isExteriorRing');\\n    }\\n  }]);\\n\\n  return Ring;\\n}();\\n\\nvar Poly = exports.Poly = function () {\\n  function Poly(exteriorRing) {\\n    _classCallCheck(this, Poly);\\n\\n    this.exteriorRing = exteriorRing;\\n    exteriorRing.registerPoly(this);\\n    this.interiorRings = [];\\n  }\\n\\n  _createClass(Poly, [{\\n    key: 'addInterior',\\n    value: function addInterior(ring) {\\n      this.interiorRings.push(ring);\\n      ring.registerPoly(this);\\n    }\\n  }, {\\n    key: 'getGeom',\\n    value: function getGeom() {\\n      var geom = [this.exteriorRing.getGeom()];\\n      // exterior ring was all (within rounding error of angle calc) colinear points\\n      if (geom[0] === null) return null;\\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\\n        var ringGeom = this.interiorRings[i].getGeom();\\n        // interior ring was all (within rounding error of angle calc) colinear points\\n        if (ringGeom === null) continue;\\n        geom.push(ringGeom);\\n      }\\n      return geom;\\n    }\\n  }]);\\n\\n  return Poly;\\n}();\\n\\nvar MultiPoly = exports.MultiPoly = function () {\\n  function MultiPoly(rings) {\\n    _classCallCheck(this, MultiPoly);\\n\\n    this.rings = rings;\\n    this.polys = this._composePolys(rings);\\n  }\\n\\n  _createClass(MultiPoly, [{\\n    key: 'getGeom',\\n    value: function getGeom() {\\n      var geom = [];\\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\\n        var polyGeom = this.polys[i].getGeom();\\n        // exterior ring was all (within rounding error of angle calc) colinear points\\n        if (polyGeom === null) continue;\\n        geom.push(polyGeom);\\n      }\\n      return geom;\\n    }\\n  }, {\\n    key: '_composePolys',\\n    value: function _composePolys(rings) {\\n      var polys = [];\\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\\n        var ring = rings[i];\\n        if (ring.poly) continue;\\n        if (ring.isExteriorRing) polys.push(new Poly(ring));else {\\n          if (!ring.enclosingRing.poly) polys.push(new Poly(ring.enclosingRing));\\n          ring.enclosingRing.poly.addInterior(ring);\\n        }\\n      }\\n      return polys;\\n    }\\n  }]);\\n\\n  return MultiPoly;\\n}();\\n\\n//# sourceURL=webpack://polygon-clipping/./src/geom-out.js?\");\n\n/***/ }),\n\n/***/ \"./src/index.js\":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = doIt;\\n\\nvar _qheap = __webpack_require__(/*! qheap */ \\\"./node_modules/qheap/index.js\\\");\\n\\nvar _qheap2 = _interopRequireDefault(_qheap);\\n\\nvar _cleanInput = __webpack_require__(/*! ./clean-input.js */ \\\"./src/clean-input.js\\\");\\n\\nvar cleanInput = _interopRequireWildcard(_cleanInput);\\n\\nvar _geomIn = __webpack_require__(/*! ./geom-in */ \\\"./src/geom-in.js\\\");\\n\\nvar geomIn = _interopRequireWildcard(_geomIn);\\n\\nvar _geomOut = __webpack_require__(/*! ./geom-out */ \\\"./src/geom-out.js\\\");\\n\\nvar geomOut = _interopRequireWildcard(_geomOut);\\n\\nvar _operation = __webpack_require__(/*! ./operation */ \\\"./src/operation.js\\\");\\n\\nvar _operation2 = _interopRequireDefault(_operation);\\n\\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \\\"./src/sweep-event.js\\\");\\n\\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\\n\\nvar _sweepLine = __webpack_require__(/*! ./sweep-line */ \\\"./src/sweep-line.js\\\");\\n\\nvar _sweepLine2 = _interopRequireDefault(_sweepLine);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction doIt(operationType, geom, moreGeoms) {\\n  /* Make a copy of the input geometry with points as objects, for perf */\\n  var geoms = [cleanInput.pointsAsObjects(geom)];\\n  for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\\n    geoms.push(cleanInput.pointsAsObjects(moreGeoms[i]));\\n  }\\n\\n  /* Clean inputs */\\n  for (var _i = 0, _iMax = geoms.length; _i < _iMax; _i++) {\\n    cleanInput.forceMultiPoly(geoms[_i]);\\n    cleanInput.cleanMultiPoly(geoms[_i]);\\n  }\\n\\n  /* Convert inputs to MultiPoly objects, mark subject & register operation */\\n  var multipolys = [];\\n  for (var _i2 = 0, _iMax2 = geoms.length; _i2 < _iMax2; _i2++) {\\n    multipolys.push(new geomIn.MultiPoly(geoms[_i2]));\\n  }\\n  multipolys[0].markAsSubject();\\n  _operation2.default.register(operationType, multipolys.length);\\n\\n  /* Put segment endpoints in a priority queue */\\n  var queue = new _qheap2.default({ comparBefore: _sweepEvent2.default.compareBefore });\\n  for (var _i3 = 0, _iMax3 = multipolys.length; _i3 < _iMax3; _i3++) {\\n    var sweepEvents = multipolys[_i3].getSweepEvents();\\n    for (var j = 0, jMax = sweepEvents.length; j < jMax; j++) {\\n      queue.insert(sweepEvents[j]);\\n    }\\n  }\\n\\n  /* Pass the sweep line over those endpoints */\\n  var sweepLine = new _sweepLine2.default();\\n  while (queue.length) {\\n    var newEvents = sweepLine.process(queue.remove());\\n    for (var _i4 = 0, _iMax4 = newEvents.length; _i4 < _iMax4; _i4++) {\\n      queue.insert(newEvents[_i4]);\\n    }\\n  }\\n\\n  /* Error on self-crossing input rings */\\n  cleanInput.errorOnSelfIntersectingRings(sweepLine.segments);\\n\\n  /* Collect and compile segments we're keeping into a multipolygon */\\n  var ringsOut = geomOut.Ring.factory(sweepLine.segments);\\n  var result = new geomOut.MultiPoly(ringsOut);\\n  return result.getGeom();\\n}\\n\\n//# sourceURL=webpack://polygon-clipping/./src/index.js?\");\n\n/***/ }),\n\n/***/ \"./src/operation.js\":\n/*!**************************!*\\\n  !*** ./src/operation.js ***!\n  \\**************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar Operation = function () {\\n  function Operation() {\\n    _classCallCheck(this, Operation);\\n\\n    this.types = {\\n      INTERSECTION: 0,\\n      UNION: 1,\\n      XOR: 2,\\n      DIFFERENCE: 3\\n    };\\n  }\\n\\n  _createClass(Operation, [{\\n    key: \\\"register\\\",\\n    value: function register(type, numMultiPolys) {\\n      this.type = type;\\n      this.numMultiPolys = numMultiPolys;\\n    }\\n  }]);\\n\\n  return Operation;\\n}();\\n\\n// global to register details about the operation on\\n\\n\\nvar operation = new Operation();\\n\\nexports.default = operation;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/operation.js?\");\n\n/***/ }),\n\n/***/ \"./src/segment.js\":\n/*!************************!*\\\n  !*** ./src/segment.js ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _operation = __webpack_require__(/*! ./operation */ \\\"./src/operation.js\\\");\\n\\nvar _operation2 = _interopRequireDefault(_operation);\\n\\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \\\"./src/sweep-event.js\\\");\\n\\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\\n\\nvar _bbox = __webpack_require__(/*! ./bbox */ \\\"./src/bbox.js\\\");\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar Segment = function () {\\n  _createClass(Segment, null, [{\\n    key: 'compare',\\n    value: function compare(a, b) {\\n      if (a === b) return 0;\\n\\n      var alx = a.leftSE.point.x;\\n      var aly = a.leftSE.point.y;\\n      var blx = b.leftSE.point.x;\\n      var bly = b.leftSE.point.y;\\n      var arx = a.rightSE.point.x;\\n      var brx = b.rightSE.point.x;\\n\\n      // check if they're even in the same vertical plane\\n      if ((0, _flp.cmp)(brx, alx) < 0) return 1;\\n      if ((0, _flp.cmp)(arx, blx) < 0) return -1;\\n\\n      var cmpLeft = a.comparePoint(b.leftSE.point);\\n      var cmpLX = (0, _flp.cmp)(alx, blx);\\n\\n      // are a and b colinear?\\n      if (cmpLeft === 0 && a.comparePoint(b.rightSE.point) === 0 && b.comparePoint(a.leftSE.point) === 0 && b.comparePoint(a.rightSE.point) === 0) {\\n        // colinear segments with non-matching left-endpoints, consider\\n        // the more-left endpoint to be earlier\\n        if (cmpLX !== 0) return cmpLX;\\n\\n        // colinear segments with matching left-endpoints, fall back\\n        // on creation order of segments as a tie-breaker\\n        // NOTE: we do not use segment length to break a tie here, because\\n        //       when segments are split their length changes\\n        if (a.ringIn.id !== b.ringIn.id) {\\n          return a.ringIn.id < b.ringIn.id ? -1 : 1;\\n        }\\n      } else {\\n        // not colinear\\n\\n        // if the our left endpoints are not in the same vertical line,\\n        // consider a vertical line at the rightmore of the two left endpoints,\\n        // consider the segment that intersects lower with that line to be earlier\\n        if (cmpLX < 0) return cmpLeft === 1 ? -1 : 1;\\n        if (cmpLX > 0) return b.comparePoint(a.leftSE.point) === 1 ? 1 : -1;\\n\\n        // if our left endpoints match, consider the segment\\n        // that angles more downward to be earlier\\n        if (cmpLX === 0 && (0, _flp.cmp)(a.leftSE.point.y, b.leftSE.point.y) === 0) {\\n          return a.comparePoint(b.rightSE.point) > 0 ? -1 : 1;\\n        }\\n\\n        // left endpoints are in the same vertical line but don't overlap exactly,\\n        // lower means ealier\\n        return (0, _flp.cmp)(aly, bly);\\n      }\\n\\n      throw new Error('Segment comparison (from [' + a.leftSE.point.x + ', ' + a.leftSR.point.y + '])' + (' -> to [' + a.rightSE.point.x + ', ' + a.rightSE.point.y + ']) failed... ') + ' segments equal but not identical?');\\n    }\\n  }]);\\n\\n  function Segment(point1, point2, ring) {\\n    _classCallCheck(this, Segment);\\n\\n    this.ringIn = ring;\\n    this.ringOut = null;\\n\\n    var ptCmp = (0, _flp.cmpPoints)(point1, point2);\\n    var lp = void 0;\\n    var rp = void 0;\\n    if (ptCmp < 0) {\\n      lp = point1;\\n      rp = point2;\\n      this.flowL2R = true;\\n    } else if (ptCmp > 0) {\\n      lp = point2;\\n      rp = point1;\\n      this.flowL2R = false;\\n    } else {\\n      throw new Error('Tried to create degenerate segment at [' + point1.x + ', ' + point1.y + ']');\\n    }\\n\\n    this.leftSE = new _sweepEvent2.default(lp, this);\\n    this.rightSE = new _sweepEvent2.default(rp, this);\\n\\n    // cache of dynamically computed properies\\n    this._clearCache();\\n  }\\n\\n  _createClass(Segment, [{\\n    key: 'clone',\\n    value: function clone() {\\n      var seg = new Segment(this.leftSE.point, this.rightSE.point, this.ringIn);\\n      seg.flowL2R = this.flowL2R;\\n      return seg;\\n    }\\n  }, {\\n    key: 'getOtherSE',\\n    value: function getOtherSE(se) {\\n      if (se === this.leftSE) return this.rightSE;\\n      if (se === this.rightSE) return this.leftSE;\\n      throw new Error('may only be called by own sweep events');\\n    }\\n  }, {\\n    key: 'isAnEndpoint',\\n    value: function isAnEndpoint(point) {\\n      return (0, _flp.cmpPoints)(point, this.leftSE.point) === 0 || (0, _flp.cmpPoints)(point, this.rightSE.point) === 0;\\n    }\\n  }, {\\n    key: 'isPointOn',\\n    value: function isPointOn(point) {\\n      return (0, _bbox.isInBbox)(this.bbox, point) && this.comparePoint(point) === 0;\\n    }\\n\\n    /* Compare this segment with a point. Return value indicates\\n     *    1: point is below segment\\n     *    0: point is colinear to segment\\n     *   -1: point is above segment */\\n\\n  }, {\\n    key: 'comparePoint',\\n    value: function comparePoint(point) {\\n      if (this.isAnEndpoint(point)) return 0;\\n      return (0, _vector.compareVectorAngles)(point, this.leftSE.point, this.rightSE.point);\\n    }\\n\\n    /**\\n     * Given another segment, returns an array of intersection points\\n     * between the two segments. The returned array can contain:\\n     *  * zero points:  no intersection b/t segments\\n     *  * one point:    segments intersect once\\n     *  * two points:   segments overlap. Endpoints of overlap returned.\\n     *                  Will be ordered as sweep line would encounter them.\\n     */\\n\\n  }, {\\n    key: 'getIntersections',\\n    value: function getIntersections(other) {\\n      // If bboxes don't overlap, there can't be any intersections\\n      var bboxOverlap = (0, _bbox.getBboxOverlap)(this.bbox, other.bbox);\\n      if (bboxOverlap === null) return [];\\n\\n      // The general algorithim doesn't handle overlapping colinear segments.\\n      // Overlapping colinear segments, if present, will have intersections\\n      // of one pair of opposing corners of the bbox overlap. Thus we just\\n      // manually check those coordinates.\\n      //\\n      // Note this also handles the cases of a collapsed bbox (just one point)\\n      // and semi-collapsed bbox (a vertical or horizontal line) as well.\\n      //\\n      // In addition, in the case of a T-intersection, this ensures that the\\n      // interseciton returned matches exactly an endpoint - no rounding error.\\n      var intersections = [];\\n      var bboxCorners = (0, _bbox.getUniqueCorners)(bboxOverlap);\\n      for (var i = 0, iMax = bboxCorners.length; i < iMax; i++) {\\n        var point = bboxCorners[i];\\n        // test if this point is an intersection\\n        if (this.isAnEndpoint(point) && other.isPointOn(point) || other.isAnEndpoint(point) && this.isPointOn(point)) {\\n          intersections.push(point);\\n        }\\n      }\\n      if (intersections.length > 0) return intersections;\\n\\n      // General case for non-overlapping segments.\\n      // This algorithm is based on Schneider and Eberly.\\n      // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\\n      var al = this.leftSE.point;\\n      var bl = other.leftSE.point;\\n      var va = this.vector;\\n      var vb = other.vector;\\n      var ve = { x: bl.x - al.x, y: bl.y - al.y };\\n      var kross = (0, _vector.crossProduct)(va, vb);\\n\\n      // not on line segment a\\n      var s = (0, _vector.crossProduct)(ve, vb) / kross;\\n      if ((0, _flp.cmp)(s, 0) < 0 || (0, _flp.cmp)(1, s) < 0) return [];\\n\\n      var t = (0, _vector.crossProduct)(ve, va) / kross;\\n      if ((0, _flp.cmp)(t, 0) < 0 || (0, _flp.cmp)(1, t) < 0) return [];\\n\\n      // intersection is in a midpoint of both lines, let's average them and\\n      // bound the result by org bbox (otherwise leftSE and rightSE could swap)\\n      var x = (al.x + s * va.x + bl.x + t * vb.x) / 2;\\n      var y = (al.y + s * va.y + bl.y + t * vb.y) / 2;\\n      if (x < bboxOverlap.ll.x) x = bboxOverlap.ll.x;\\n      if (x > bboxOverlap.ur.x) x = bboxOverlap.ur.x;\\n      if (y < bboxOverlap.ll.y) y = bboxOverlap.ll.y;\\n      if (y > bboxOverlap.ur.y) y = bboxOverlap.ur.y;\\n      return [{ x: x, y: y }];\\n    }\\n\\n    /**\\n     * Split the given segment into multiple segments on the given points.\\n     *  * The existing segment will retain it's leftSE and a new rightSE will be\\n     *    generated for it.\\n     *  * A new segment will be generated which will adopt the original segment's\\n     *    rightSE, and a new leftSE will be generated for it.\\n     *  * If there are more than two points given to split on, new segments\\n     *    in the middle will be generated with new leftSE and rightSE's.\\n     *  * An array of the newly generated SweepEvents will be returned.\\n     */\\n\\n  }, {\\n    key: 'split',\\n    value: function split(points) {\\n      // sort them and unique-ify them\\n      points.sort(_flp.cmpPoints);\\n      points = points.filter(function (pt, i, pts) {\\n        return i === 0 || (0, _flp.cmpPoints)(pts[i - 1], pt) !== 0;\\n      });\\n\\n      for (var i = 0, iMax = points.length; i < iMax; i++) {\\n        var pt = points[i];\\n        if (this.isAnEndpoint(pt)) {\\n          throw new Error('Cannot split segment upon endpoint at [' + pt.x + ', ' + pt.y + ']');\\n        }\\n      }\\n\\n      var point = points.shift();\\n      var newSeg = this.clone();\\n      newSeg.leftSE = new _sweepEvent2.default(point, newSeg);\\n      newSeg.rightSE = this.rightSE;\\n      this.rightSE.segment = newSeg;\\n      this.rightSE = new _sweepEvent2.default(point, this);\\n      var newEvents = [this.rightSE, newSeg.leftSE];\\n\\n      if (points.length > 0) {\\n        var moreNewEvents = newSeg.split(points);\\n        for (var _i = 0, _iMax = moreNewEvents.length; _i < _iMax; _i++) {\\n          newEvents.push(moreNewEvents[_i]);\\n        }\\n      }\\n      return newEvents;\\n    }\\n  }, {\\n    key: 'registerPrev',\\n    value: function registerPrev(other) {\\n      this.prev = other;\\n      this._clearCache();\\n    }\\n  }, {\\n    key: 'registerRingOut',\\n    value: function registerRingOut(ring) {\\n      this.ringOut = ring;\\n    }\\n\\n    /* The first segment previous segment chain that is in the result */\\n\\n  }, {\\n    key: '_prevInResult',\\n    value: function _prevInResult() {\\n      var prev = this.prev;\\n      while (prev && !prev.isInResult) {\\n        prev = prev.prev;\\n      }return prev;\\n    }\\n\\n    /* The segments, including ourselves, for which we overlap perfectly */\\n\\n  }, {\\n    key: '_coincidents',\\n    value: function _coincidents() {\\n      // a coincident will have both left and right sweepEvents linked with us\\n      var coincidents = [];\\n      var leftLinkedEvents = this.leftSE.linkedEvents;\\n      var rightLinkedEvents = this.rightSE.linkedEvents;\\n      for (var i = 0, iMax = leftLinkedEvents.length; i < iMax; i++) {\\n        var leftSE = leftLinkedEvents[i];\\n        if (!leftSE.isLeft) continue;\\n        if (leftSE.segment.rightSE.linkedEvents !== rightLinkedEvents) continue;\\n        coincidents.push(leftSE.segment);\\n      }\\n\\n      if (coincidents.length > 0) {\\n        // put the 'winner' at the front\\n        // arbitary - winner is the one with lowest ringId\\n        coincidents.sort(function (a, b) {\\n          return a.ringIn.id - b.ringIn.id;\\n        });\\n\\n        // set this in all our coincident's caches so they don't have to calc it\\n        for (var _i2 = 0, _iMax2 = coincidents.length; _i2 < _iMax2; _i2++) {\\n          coincidents[_i2]._cache['coincidents'] = coincidents;\\n        }\\n      }\\n      return coincidents;\\n    }\\n  }, {\\n    key: '_prevNotCoincident',\\n    value: function _prevNotCoincident() {\\n      // iterating backwards from next to prev\\n      var next = this;\\n      var prev = this.prev;\\n      while (prev && next.coincidents === prev.coincidents) {\\n        next = prev;\\n        prev = prev.prev;\\n      }\\n      return prev;\\n    }\\n\\n    /* Does the sweep line, when it intersects this segment, enter the ring? */\\n\\n  }, {\\n    key: '_sweepLineEntersRing',\\n    value: function _sweepLineEntersRing() {\\n      // opposite of previous segment on the same ring\\n      var prev = this.prevNotCoincident;\\n      while (prev) {\\n        for (var i = 0, iMax = prev.coincidents.length; i < iMax; i++) {\\n          var seg = prev.coincidents[i];\\n          if (seg.ringIn === this.ringIn) return !seg.sweepLineEntersRing;\\n        }\\n        prev = prev.prevNotCoincident;\\n      }\\n      return true;\\n    }\\n\\n    /* Does the sweep line, when it intersects this segment, enter the polygon? */\\n\\n  }, {\\n    key: '_ringsInsideOf',\\n    value: function _ringsInsideOf() {\\n      if (!this.prev) return [];\\n\\n      // coincidents always share the same rings. Return same array to save mem\\n      if (this.coincidents === this.prev.coincidents) {\\n        return this.prev.ringsInsideOf;\\n      }\\n\\n      var rings = [];\\n      var prevRingsInsideOf = this.prev.ringsInsideOf;\\n      var prevRingsEntering = this.prev.getRingsEntering();\\n      var ringsExiting = this.getRingsExiting();\\n\\n      // rings our prev was inside of all count, except those we're exiting\\n      for (var i = 0, iMax = prevRingsInsideOf.length; i < iMax; i++) {\\n        var ring = prevRingsInsideOf[i];\\n        if (!ringsExiting.includes(ring)) rings.push(ring);\\n      }\\n\\n      // rings our prev was entering of all count, except those we're exiting\\n      for (var _i3 = 0, _iMax3 = prevRingsEntering.length; _i3 < _iMax3; _i3++) {\\n        var _ring = prevRingsEntering[_i3];\\n        if (!ringsExiting.includes(_ring)) rings.push(_ring);\\n      }\\n\\n      return rings;\\n    }\\n\\n    /* Array of input rings this segment is on boundary of */\\n\\n  }, {\\n    key: 'getRingsOnEdgeOf',\\n    value: function getRingsOnEdgeOf() {\\n      var rings = [];\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        rings.push(this.coincidents[i].ringIn);\\n      }\\n      return rings;\\n    }\\n\\n    /* Array of input rings this segment is on boundary of,\\n     * and for which the sweep line enters when intersecting there */\\n\\n  }, {\\n    key: 'getRingsEntering',\\n    value: function getRingsEntering() {\\n      var rings = [];\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var segment = this.coincidents[i];\\n        if (!segment.sweepLineEntersRing) continue;\\n        rings.push(segment.ringIn);\\n      }\\n      return rings;\\n    }\\n\\n    /* Array of input rings this segment is on boundary of,\\n     * and for which the sweep line exits when intersecting there */\\n\\n  }, {\\n    key: 'getRingsExiting',\\n    value: function getRingsExiting() {\\n      var rings = [];\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var segment = this.coincidents[i];\\n        if (segment.sweepLineEntersRing) continue;\\n        rings.push(segment.ringIn);\\n      }\\n      return rings;\\n    }\\n\\n    /* Is this segment valid on our own polygon? (ie not outside exterior ring) */\\n\\n  }, {\\n    key: '_isValidEdgeForPoly',\\n    value: function _isValidEdgeForPoly() {\\n      // SLER: sweep line entering orientation\\n      var sameSLER = void 0;\\n      var diffSLER = void 0;\\n      if (this.sweepLineEntersRing) {\\n        sameSLER = this.getRingsEntering();\\n        diffSLER = this.getRingsExiting();\\n      } else {\\n        diffSLER = this.getRingsEntering();\\n        sameSLER = this.getRingsExiting();\\n      }\\n      return this.ringIn.isValid(sameSLER, diffSLER, this.ringsInsideOf);\\n    }\\n\\n    /* Array of multipolys this segment is inside of */\\n\\n  }, {\\n    key: 'getMultiPolysInsideOf',\\n    value: function getMultiPolysInsideOf() {\\n      var mps = [];\\n      for (var i = 0, iMax = this.ringsInsideOf.length; i < iMax; i++) {\\n        var poly = this.ringsInsideOf[i].poly;\\n        if (mps.includes(poly.multiPoly)) continue;\\n        if (!poly.isInside(this.getRingsOnEdgeOf(), this.ringsInsideOf)) continue;\\n        mps.push(poly.multiPoly);\\n      }\\n      return mps;\\n    }\\n\\n    /* The multipolys on one side of us */\\n\\n  }, {\\n    key: 'getMultiPolysSLPEnters',\\n    value: function getMultiPolysSLPEnters(multiPolysInsideOf) {\\n      // start with the multipolys we're fully inside\\n      var mps = multiPolysInsideOf.slice();\\n      // add the multipolys we have the sweep line entering\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var seg = this.coincidents[i];\\n        if (!seg.sweepLineEntersPoly) continue;\\n        var mp = seg.ringIn.poly.multiPoly;\\n        if (!mps.includes(mp)) mps.push(mp);\\n      }\\n      return mps;\\n    }\\n\\n    /* The multipolys on the other side of us */\\n\\n  }, {\\n    key: 'getMultiPolysSLPExits',\\n    value: function getMultiPolysSLPExits(multiPolysInsideOf) {\\n      // start with the multipolys we're fully inside\\n      var mps = multiPolysInsideOf.slice();\\n      // add the multipolys we have the sweep line entering\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var seg = this.coincidents[i];\\n        if (!seg.sweepLineExitsPoly) continue;\\n        var mp = seg.ringIn.poly.multiPoly;\\n        if (!mps.includes(mp)) mps.push(mp);\\n      }\\n      return mps;\\n    }\\n\\n    /* Is this segment part of the final result? */\\n\\n  }, {\\n    key: '_isInResult',\\n    value: function _isInResult() {\\n      // if it's not the coincidence winner, it's not in the resul\\n      if (this !== this.coincidents[0]) return false;\\n\\n      var multiPolysInsideOf = this.getMultiPolysInsideOf();\\n      var multiPolysSLPEnters = this.getMultiPolysSLPEnters(multiPolysInsideOf);\\n      var multiPolysSLPExits = this.getMultiPolysSLPExits(multiPolysInsideOf);\\n\\n      switch (_operation2.default.type) {\\n        case _operation2.default.types.UNION:\\n          // UNION - included iff:\\n          //  * On one side of us there is 0 poly interiors AND\\n          //  * On the other side there is 1 or more.\\n          var noEnters = multiPolysSLPEnters.length === 0;\\n          var noExits = multiPolysSLPExits.length === 0;\\n          return noEnters !== noExits;\\n\\n        case _operation2.default.types.INTERSECTION:\\n          // INTERSECTION - included iff:\\n          //  * on one side of us all multipolys are rep. with poly interiors AND\\n          //  * on the other side of us, not all multipolys are repsented\\n          //    with poly interiors\\n          var least = void 0;\\n          var most = void 0;\\n          if (multiPolysSLPEnters.length < multiPolysSLPExits.length) {\\n            least = multiPolysSLPEnters.length;\\n            most = multiPolysSLPExits.length;\\n          } else {\\n            least = multiPolysSLPExits.length;\\n            most = multiPolysSLPEnters.length;\\n          }\\n          return most === _operation2.default.numMultiPolys && least < most;\\n\\n        case _operation2.default.types.XOR:\\n          // XOR - included iff:\\n          //  * the difference between the number of multipolys represented\\n          //    with poly interiors on our two sides is an odd number\\n          var diff = Math.abs(multiPolysSLPEnters.length - multiPolysSLPExits.length);\\n          return diff % 2 === 1;\\n\\n        case _operation2.default.types.DIFFERENCE:\\n          // DIFFERENCE included iff:\\n          //  * on exactly one side, we have just the subject\\n          var isJustSubject = function isJustSubject(mps) {\\n            return mps.length === 1 && mps[0].isSubject;\\n          };\\n          return isJustSubject(multiPolysSLPEnters) !== isJustSubject(multiPolysSLPExits);\\n\\n        default:\\n          throw new Error('Unrecognized operation type found ' + _operation2.default.type);\\n      }\\n    }\\n  }, {\\n    key: '_clearCache',\\n    value: function _clearCache() {\\n      this._cache = {};\\n    }\\n  }, {\\n    key: 'bbox',\\n    get: function get() {\\n      var y1 = this.leftSE.point.y;\\n      var y2 = this.rightSE.point.y;\\n      return {\\n        ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\\n        ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\\n      };\\n    }\\n\\n    /* A vector from the left point to the right */\\n\\n  }, {\\n    key: 'vector',\\n    get: function get() {\\n      return {\\n        x: this.rightSE.point.x - this.leftSE.point.x,\\n        y: this.rightSE.point.y - this.leftSE.point.y\\n      };\\n    }\\n  }, {\\n    key: 'isVertical',\\n    get: function get() {\\n      return (0, _flp.cmp)(this.leftSE.point.x, this.rightSE.point.x) === 0;\\n    }\\n\\n    /* In the original ringIn, which event came second */\\n\\n  }, {\\n    key: 'flowIntoSE',\\n    get: function get() {\\n      return this.flowL2R ? this.rightSE : this.leftSE;\\n    }\\n  }, {\\n    key: 'prevInResult',\\n    get: function get() {\\n      var key = 'prevInResult';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'coincidents',\\n    get: function get() {\\n      var key = 'coincidents';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'prevNotCoincident',\\n    get: function get() {\\n      var key = 'prevNotCoincident';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'sweepLineEntersRing',\\n    get: function get() {\\n      var key = 'sweepLineEntersRing';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'sweepLineEntersPoly',\\n    get: function get() {\\n      if (!this.isValidEdgeForPoly) return false;\\n      return this.ringIn.isExterior === this.sweepLineEntersRing;\\n    }\\n\\n    /* Does the sweep line, when it intersects this segment, exit the polygon? */\\n\\n  }, {\\n    key: 'sweepLineExitsPoly',\\n    get: function get() {\\n      if (!this.isValidEdgeForPoly) return false;\\n      return this.ringIn.isExterior !== this.sweepLineEntersRing;\\n    }\\n\\n    /* Array of input rings this segment is inside of (not on boundary) */\\n\\n  }, {\\n    key: 'ringsInsideOf',\\n    get: function get() {\\n      var key = 'ringsInsideOf';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'isValidEdgeForPoly',\\n    get: function get() {\\n      var key = 'isValidEdgeForPoly';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'isInResult',\\n    get: function get() {\\n      var key = 'isInResult';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }]);\\n\\n  return Segment;\\n}();\\n\\nexports.default = Segment;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/segment.js?\");\n\n/***/ }),\n\n/***/ \"./src/sweep-event.js\":\n/*!****************************!*\\\n  !*** ./src/sweep-event.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar SweepEvent = function () {\\n  _createClass(SweepEvent, null, [{\\n    key: 'compareBefore',\\n    value: function compareBefore(a, b) {\\n      // favor event with a point that the sweep line hits first\\n      var cmpX = (0, _flp.cmp)(a.point.x, b.point.x);\\n      if (cmpX !== 0) return cmpX < 0;\\n\\n      var cmpY = (0, _flp.cmp)(a.point.y, b.point.y);\\n      if (cmpY !== 0) return cmpY < 0;\\n\\n      // favor right events over left\\n      if (a.isLeft !== b.isLeft) return !a.isLeft;\\n\\n      // favor events where the line segment is lower\\n      var pointSegCmp = a.segment.comparePoint(b.otherSE.point);\\n      if (pointSegCmp !== 0) return pointSegCmp > 0;\\n\\n      // as a tie-breaker, favor lower segment creation id\\n      var aId = a.segment.ringIn.id;\\n      var bId = b.segment.ringIn.id;\\n      if (aId !== bId) return aId < bId;\\n\\n      // NOTE:  We don't sort on segment length because that changes\\n      //        as segments are divided.\\n\\n      // they appear to be the same point... are they?\\n      if (a === b) return false;\\n\\n      throw new Error('SweepEvent comparison failed at [' + a.point.x + ', ' + a.point.y + ']... ' + 'equal but not identical?');\\n    }\\n  }]);\\n\\n  function SweepEvent(point, segment) {\\n    _classCallCheck(this, SweepEvent);\\n\\n    this.point = point;\\n    this.segment = segment;\\n    this.linkedEvents = [this];\\n  }\\n\\n  _createClass(SweepEvent, [{\\n    key: 'link',\\n    value: function link(other) {\\n      var otherLE = other.linkedEvents;\\n      for (var i = 0, iMax = otherLE.length; i < iMax; i++) {\\n        var evt = otherLE[i];\\n        this.linkedEvents.push(evt);\\n        evt.linkedEvents = this.linkedEvents;\\n      }\\n    }\\n  }, {\\n    key: 'getAvailableLinkedEvents',\\n    value: function getAvailableLinkedEvents() {\\n      var events = [];\\n      for (var i = 0, iMax = this.linkedEvents.length; i < iMax; i++) {\\n        var evt = this.linkedEvents[i];\\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult) {\\n          events.push(evt);\\n        }\\n      }\\n      return events;\\n    }\\n\\n    /**\\n     * Returns a comparator function for sorting linked events that will\\n     * favor the event that will give us the smallest left-side angle.\\n     * All ring construction starts as low as possible heading to the right,\\n     * so by always turning left as sharp as possible we'll get polygons\\n     * without uncessary loops & holes.\\n     *\\n     * The comparator function has a compute cache such that it avoids\\n     * re-computing already-computed values.\\n     */\\n\\n  }, {\\n    key: 'getLeftmostComparator',\\n    value: function getLeftmostComparator(baseEvent) {\\n      var _this = this;\\n\\n      var cache = new Map();\\n\\n      var fillCache = function fillCache(linkedEvent) {\\n        var nextEvent = linkedEvent.otherSE;\\n        cache.set(linkedEvent, {\\n          sine: (0, _vector.sineOfAngle)(_this.point, baseEvent.point, nextEvent.point),\\n          cosine: (0, _vector.cosineOfAngle)(_this.point, baseEvent.point, nextEvent.point)\\n        });\\n      };\\n\\n      return function (a, b) {\\n        if (!cache.has(a)) fillCache(a);\\n        if (!cache.has(b)) fillCache(b);\\n\\n        var _cache$get = cache.get(a),\\n            asine = _cache$get.sine,\\n            acosine = _cache$get.cosine;\\n\\n        var _cache$get2 = cache.get(b),\\n            bsine = _cache$get2.sine,\\n            bcosine = _cache$get2.cosine;\\n\\n        var cmpZeroASine = (0, _flp.cmp)(asine, 0);\\n        var cmpZeroBSine = (0, _flp.cmp)(bsine, 0);\\n\\n        if (cmpZeroASine >= 0 && cmpZeroBSine >= 0) return (0, _flp.cmp)(bcosine, acosine);\\n        if (cmpZeroASine < 0 && cmpZeroBSine < 0) return (0, _flp.cmp)(acosine, bcosine);\\n        return (0, _flp.cmp)(bsine, asine);\\n      };\\n    }\\n  }, {\\n    key: 'isLeft',\\n    get: function get() {\\n      return this === this.segment.leftSE;\\n    }\\n  }, {\\n    key: 'isRight',\\n    get: function get() {\\n      return this === this.segment.rightSE;\\n    }\\n  }, {\\n    key: 'otherSE',\\n    get: function get() {\\n      return this.segment.getOtherSE(this);\\n    }\\n  }]);\\n\\n  return SweepEvent;\\n}();\\n\\nexports.default = SweepEvent;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/sweep-event.js?\");\n\n/***/ }),\n\n/***/ \"./src/sweep-line.js\":\n/*!***************************!*\\\n  !*** ./src/sweep-line.js ***!\n  \\***************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _splaytree = __webpack_require__(/*! splaytree */ \\\"./node_modules/splaytree/index.js\\\");\\n\\nvar _splaytree2 = _interopRequireDefault(_splaytree);\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _segment = __webpack_require__(/*! ./segment */ \\\"./src/segment.js\\\");\\n\\nvar _segment2 = _interopRequireDefault(_segment);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n * NOTE:  We must be careful not to change any segments while\\n *        they are in the SplayTree. AFAIK, there's no way to tell\\n *        the tree to rebalance itself - thus before splitting\\n *        a segment that's in the tree, we remove it from the tree,\\n *        do the split, then re-insert it. (Even though splitting a\\n *        segment *shouldn't* change its correct position in the\\n *        sweep line tree, the reality is because of rounding errors,\\n *        it sometimes does.)\\n */\\n\\nvar SweepLine = function () {\\n  function SweepLine() {\\n    var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _segment2.default.compare;\\n\\n    _classCallCheck(this, SweepLine);\\n\\n    this.tree = new _splaytree2.default(comparator);\\n    this.segments = [];\\n    this.prevEvent = null;\\n  }\\n\\n  _createClass(SweepLine, [{\\n    key: 'process',\\n    value: function process(event) {\\n      var segment = event.segment;\\n      var newEvents = [];\\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\\n\\n      var prevNode = this.tree.prev(node);\\n      var prevSeg = prevNode ? prevNode.key : null;\\n\\n      var nextNode = this.tree.next(node);\\n      var nextSeg = nextNode ? nextNode.key : null;\\n\\n      if (event.isLeft) {\\n        var mySplitters = [];\\n\\n        // Check for intersections against the previous segment in the sweep line\\n        if (prevSeg) {\\n          var prevInters = prevSeg.getIntersections(segment);\\n          if (prevInters.length > 0) {\\n            var newEventsFromSplit = this._possibleSplit(prevSeg, prevInters);\\n            for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\\n              newEvents.push(newEventsFromSplit[i]);\\n            }\\n            for (var _i = 0, _iMax = prevInters.length; _i < _iMax; _i++) {\\n              var pt = prevInters[_i];\\n              if (!segment.isAnEndpoint(pt)) mySplitters.push(pt);\\n            }\\n          }\\n        }\\n\\n        // Check for intersections against the next segment in the sweep line\\n        if (nextSeg) {\\n          var nextInters = nextSeg.getIntersections(segment);\\n          if (nextInters.length > 0) {\\n            var _newEventsFromSplit = this._possibleSplit(nextSeg, nextInters);\\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit.length; _i2 < _iMax2; _i2++) {\\n              newEvents.push(_newEventsFromSplit[_i2]);\\n            }\\n            for (var _i3 = 0, _iMax3 = nextInters.length; _i3 < _iMax3; _i3++) {\\n              var _pt = nextInters[_i3];\\n              if (!segment.isAnEndpoint(_pt)) mySplitters.push(_pt);\\n            }\\n          }\\n        }\\n\\n        // did we get some intersections?\\n        if (newEvents.length > 0 || mySplitters.length > 0) {\\n          this.tree.remove(segment);\\n\\n          if (mySplitters.length > 0) {\\n            var _newEventsFromSplit2 = segment.split(mySplitters);\\n            for (var _i4 = 0, _iMax4 = _newEventsFromSplit2.length; _i4 < _iMax4; _i4++) {\\n              newEvents.push(_newEventsFromSplit2[_i4]);\\n            }\\n          }\\n\\n          // Make sure sweep line ordering is totally consistent for later\\n          // use with the segment 'prev' pointers - re-do the current event.\\n          newEvents.push(event);\\n          return newEvents;\\n        }\\n\\n        this.segments.push(segment);\\n        segment.registerPrev(prevSeg);\\n      } else {\\n        // event.isRight\\n\\n        // since we're about to be removed from the sweep line, check for\\n        // intersections between our previous and next segments\\n        if (prevSeg && nextSeg) {\\n          var inters = prevSeg.getIntersections(nextSeg);\\n          if (inters.length > 0) {\\n            var _newEventsFromSplit3 = this._possibleSplit(prevSeg, inters);\\n            for (var _i5 = 0, _iMax5 = _newEventsFromSplit3.length; _i5 < _iMax5; _i5++) {\\n              newEvents.push(_newEventsFromSplit3[_i5]);\\n            }\\n            _newEventsFromSplit3 = this._possibleSplit(nextSeg, inters);\\n            for (var _i6 = 0, _iMax6 = _newEventsFromSplit3.length; _i6 < _iMax6; _i6++) {\\n              newEvents.push(_newEventsFromSplit3[_i6]);\\n            }\\n          }\\n        }\\n\\n        this.tree.remove(segment);\\n      }\\n\\n      if (this.prevEvent && (0, _flp.cmpPoints)(this.prevEvent.point, event.point) === 0) {\\n        this.prevEvent.link(event);\\n      }\\n      this.prevEvent = event;\\n\\n      return newEvents;\\n    }\\n  }, {\\n    key: '_possibleSplit',\\n    value: function _possibleSplit(segment, intersections) {\\n      var splitters = [];\\n      for (var i = 0, iMax = intersections.length; i < iMax; i++) {\\n        var pt = intersections[i];\\n        if (!segment.isAnEndpoint(pt)) splitters.push(pt);\\n      }\\n\\n      var newEvents = void 0;\\n      if (splitters.length > 0) {\\n        this.tree.remove(segment);\\n        newEvents = segment.split(splitters);\\n        this.tree.insert(segment);\\n      } else newEvents = [];\\n      return newEvents;\\n    }\\n  }]);\\n\\n  return SweepLine;\\n}();\\n\\nexports.default = SweepLine;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/sweep-line.js?\");\n\n/***/ }),\n\n/***/ \"./src/vector.js\":\n/*!***********************!*\\\n  !*** ./src/vector.js ***!\n  \\***********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.cosineOfAngle = exports.sineOfAngle = exports.compareVectorAngles = exports.dotProduct = exports.crossProduct = undefined;\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\n/* Cross Product of two vectors with first point at origin */\\nvar crossProduct = exports.crossProduct = function crossProduct(a, b) {\\n  return a.x * b.y - a.y * b.x;\\n};\\n\\n/* Dot Product of two vectors with first point at origin */\\nvar dotProduct = exports.dotProduct = function dotProduct(a, b) {\\n  return a.x * b.x + a.y * b.y;\\n};\\n\\n/* Comparator for two vectors with same starting point */\\nvar compareVectorAngles = exports.compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\\n  var v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y };\\n  var v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y };\\n  var kross = crossProduct(v1, v2);\\n  return (0, _flp.cmp)(kross, 0);\\n};\\n\\nvar length = function length(v) {\\n  return Math.sqrt(dotProduct(v, v));\\n};\\n\\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\\nvar sineOfAngle = exports.sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\\n  var vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y };\\n  var vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y };\\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\\n};\\n\\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\\nvar cosineOfAngle = exports.cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\\n  var vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y };\\n  var vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y };\\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/vector.js?\");\n\n/***/ })\n\n/******/ });\n});","\nvar content = require(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","var escape = require(\"../node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"\\r\\n/*   Icons  */\\r\\n\\r\\n.leaflet-control-paintpolygon-icon {\\r\\n    background-image: url(\" + escape(require(\"./PaintPolygon.svg\")) + \");\\r\\n    background-repeat: no-repeat;\\r\\n    height: 30px;\\r\\n    width: 30px;\\r\\n}\\r\\n\\r\\n.leaflet-control-paintpolygon-icon-active {\\r\\n    -webkit-filter: invert(75%); /* Safari 6.0 - 9.0 */\\r\\n    filter: invert(75%);\\r\\n}\\r\\n\\r\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-trash {\\r\\n    background-position: 0px 0px;\\r\\n}\\r\\n\\r\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-brush {\\r\\n    background-position: 0px -30px;\\r\\n}\\r\\n\\r\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-eraser {\\r\\n    background-position: 0px -60px;\\r\\n}\\r\\n\\r\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-size {\\r\\n    background-position: 0px -90px;\\r\\n}\\r\\n\\r\\n\\r\\n/* Menu */\\r\\n\\r\\n.leaflet-control-paintpolygon-menu  {\\r\\n    background-color: #fff;\\r\\n    position: absolute;\\r\\n    border: 0!important;\\r\\n    max-width: 0;\\r\\n    max-height: 30px;\\r\\n    -webkit-transition: all 0.5s;\\r\\n    -moz-transition: all 0.5s;\\r\\n    -ms-transition: all 0.5s;\\r\\n    -o-transition: all 0.5s;\\r\\n    transition: all 0.5s;\\r\\n    display: inline-block;\\r\\n    overflow: hidden;\\r\\n    white-space: nowrap;\\r\\n}\\r\\n.leaflet-control-paintpolygon-menu-content  {\\r\\n    padding: 5px;\\r\\n    display: inline-block;\\r\\n    max-width: 250px;\\r\\n}\\r\\n\\r\\n.leaflet-control-paintpolygon-menu-open  {\\r\\n    border: inherit!important;\\r\\n    max-width: 250px;\\r\\n    max-height: 200px;\\r\\n}\\r\\n\\r\\n.leaflet-control-container .leaflet-top.leaflet-right .leaflet-control-paintpolygon-menu {\\r\\n    top: 60px;\\r\\n    right: 30px;\\r\\n}\\r\\n.leaflet-control-container .leaflet-top.leaflet-left .leaflet-control-paintpolygon-menu {\\r\\n    top: 60px;\\r\\n    left: 30px;\\r\\n}\\r\\n.leaflet-control-container .leaflet-bottom.leaflet-right .leaflet-control-paintpolygon-menu {\\r\\n    bottom: 0px;\\r\\n    right: 30px;\\r\\n}\\r\\n.leaflet-control-container .leaflet-bottom.leaflet-left .leaflet-control-paintpolygon-menu {\\r\\n    bottom: 0px;\\r\\n    left: 30px;\\r\\n}\\r\\n\\r\\n\", \"\"]);\n\n// exports\n","module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+DQo8IS0tIENyZWF0ZWQgd2l0aCBJbmtzY2FwZSAoaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvKSAtLT4NCg0KPHN2Zw0KICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIg0KICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyINCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyINCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciDQogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciDQogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiDQogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSINCiAgIHdpZHRoPSIzMCINCiAgIGhlaWdodD0iMTIwIg0KICAgdmlld0JveD0iMCAwIDcuOTM3NSAzMS43NTAwMDEiDQogICB2ZXJzaW9uPSIxLjEiDQogICBpZD0ic3ZnOCINCiAgIGlua3NjYXBlOnZlcnNpb249IjAuOTIuMyAoMjQwNTU0NiwgMjAxOC0wMy0xMSkiDQogICBzb2RpcG9kaTpkb2NuYW1lPSJQYWludFBvbHlnb24uc3ZnIj4NCiAgPGRlZnMNCiAgICAgaWQ9ImRlZnMyIj4NCiAgICA8bWFya2VyDQogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxU3N0YXJ0Ig0KICAgICAgIG9yaWVudD0iYXV0byINCiAgICAgICByZWZZPSIwIg0KICAgICAgIHJlZlg9IjAiDQogICAgICAgaWQ9IkFycm93MVNzdGFydCINCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSINCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4NCiAgICAgIDxwYXRoDQogICAgICAgICBpZD0icGF0aDk3MyINCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiINCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC4yLDAsMCwwLjIsMS4yLDApIg0KICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4NCiAgICA8L21hcmtlcj4NCiAgICA8bWFya2VyDQogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTWVuZCINCiAgICAgICBvcmllbnQ9ImF1dG8iDQogICAgICAgcmVmWT0iMCINCiAgICAgICByZWZYPSIwIg0KICAgICAgIGlkPSJtYXJrZXIxNTIzIg0KICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIg0KICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPg0KICAgICAgPHBhdGgNCiAgICAgICAgIGlkPSJwYXRoMTUyMSINCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiINCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuNCwwLDAsLTAuNCwtNCwwKSINCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+DQogICAgPC9tYXJrZXI+DQogICAgPG1hcmtlcg0KICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiDQogICAgICAgb3JpZW50PSJhdXRvIg0KICAgICAgIHJlZlk9IjAiDQogICAgICAgcmVmWD0iMCINCiAgICAgICBpZD0iQXJyb3cyTGVuZCINCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSINCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4NCiAgICAgIDxwYXRoDQogICAgICAgICBpZD0icGF0aDk4MiINCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiDQogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMS4xLDAsMCwtMS4xLC0xLjEsMCkiDQogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPg0KICAgIDwvbWFya2VyPg0KICAgIDxtYXJrZXINCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzFMZW5kIg0KICAgICAgIG9yaWVudD0iYXV0byINCiAgICAgICByZWZZPSIwIg0KICAgICAgIHJlZlg9IjAiDQogICAgICAgaWQ9IkFycm93MUxlbmQiDQogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiDQogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+DQogICAgICA8cGF0aA0KICAgICAgICAgaWQ9InBhdGg5NjQiDQogICAgICAgICBkPSJNIDAsMCA1LC01IC0xMi41LDAgNSw1IFoiDQogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjAwMDAwMDAzcHQ7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjgsMCwwLC0wLjgsLTEwLDApIg0KICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4NCiAgICA8L21hcmtlcj4NCiAgICA8bWFya2VyDQogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTHN0YXJ0Ig0KICAgICAgIG9yaWVudD0iYXV0byINCiAgICAgICByZWZZPSIwIg0KICAgICAgIHJlZlg9IjAiDQogICAgICAgaWQ9Im1hcmtlcjEyOTUiDQogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiDQogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+DQogICAgICA8cGF0aA0KICAgICAgICAgaWQ9InBhdGgxMjkzIg0KICAgICAgICAgZD0iTSAwLDAgNSwtNSAtMTIuNSwwIDUsNSBaIg0KICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjgsMCwwLDAuOCwxMCwwKSINCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+DQogICAgPC9tYXJrZXI+DQogICAgPG1hcmtlcg0KICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MU1lbmQiDQogICAgICAgb3JpZW50PSJhdXRvIg0KICAgICAgIHJlZlk9IjAiDQogICAgICAgcmVmWD0iMCINCiAgICAgICBpZD0iQXJyb3cxTWVuZCINCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSINCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4NCiAgICAgIDxwYXRoDQogICAgICAgICBpZD0icGF0aDk3MCINCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiINCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuNCwwLDAsLTAuNCwtNCwwKSINCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+DQogICAgPC9tYXJrZXI+DQogICAgPG1hcmtlcg0KICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MlNlbmQiDQogICAgICAgb3JpZW50PSJhdXRvIg0KICAgICAgIHJlZlk9IjAiDQogICAgICAgcmVmWD0iMCINCiAgICAgICBpZD0iQXJyb3cyU2VuZCINCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSINCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4NCiAgICAgIDxwYXRoDQogICAgICAgICBpZD0icGF0aDk5NCINCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgICAgZD0iTSA4LjcxODU4NzgsNC4wMzM3MzUyIC0yLjIwNzI4OTUsMC4wMTYwMTMyNiA4LjcxODU4ODQsLTQuMDAxNzA3OCBjIC0xLjc0NTQ5ODQsMi4zNzIwNjA5IC0xLjczNTQ0MDgsNS42MTc0NTE5IC02ZS03LDguMDM1NDQzIHoiDQogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMC4zLDAsMCwtMC4zLDAuNjksMCkiDQogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPg0KICAgIDwvbWFya2VyPg0KICAgIDxtYXJrZXINCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMc3RhcnQiDQogICAgICAgb3JpZW50PSJhdXRvIg0KICAgICAgIHJlZlk9IjAiDQogICAgICAgcmVmWD0iMCINCiAgICAgICBpZD0iQXJyb3cyTHN0YXJ0Ig0KICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIg0KICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPg0KICAgICAgPHBhdGgNCiAgICAgICAgIGlkPSJwYXRoOTc5Ig0KICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiINCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMSwwLDAsMS4xLDEuMSwwKSINCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+DQogICAgPC9tYXJrZXI+DQogICAgPG1hcmtlcg0KICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MU1zdGFydCINCiAgICAgICBvcmllbnQ9ImF1dG8iDQogICAgICAgcmVmWT0iMCINCiAgICAgICByZWZYPSIwIg0KICAgICAgIGlkPSJBcnJvdzFNc3RhcnQiDQogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiDQogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+DQogICAgICA8cGF0aA0KICAgICAgICAgaWQ9InBhdGg5NjciDQogICAgICAgICBkPSJNIDAsMCA1LC01IC0xMi41LDAgNSw1IFoiDQogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjAwMDAwMDAzcHQ7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuNCwwLDAsMC40LDQsMCkiDQogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPg0KICAgIDwvbWFya2VyPg0KICAgIDxtYXJrZXINCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzFMc3RhcnQiDQogICAgICAgb3JpZW50PSJhdXRvIg0KICAgICAgIHJlZlk9IjAiDQogICAgICAgcmVmWD0iMCINCiAgICAgICBpZD0iQXJyb3cxTHN0YXJ0Ig0KICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIg0KICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPg0KICAgICAgPHBhdGgNCiAgICAgICAgIGlkPSJwYXRoOTYxIg0KICAgICAgICAgZD0iTSAwLDAgNSwtNSAtMTIuNSwwIDUsNSBaIg0KICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjgsMCwwLDAuOCwxMCwwKSINCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+DQogICAgPC9tYXJrZXI+DQogIDwvZGVmcz4NCiAgPHNvZGlwb2RpOm5hbWVkdmlldw0KICAgICBpZD0iYmFzZSINCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIg0KICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiINCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIg0KICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCINCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiINCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiDQogICAgIGlua3NjYXBlOmN4PSIxOC4xMDI0NjUiDQogICAgIGlua3NjYXBlOmN5PSIxMTEuMTcyNDEiDQogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCINCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIg0KICAgICBzaG93Z3JpZD0idHJ1ZSINCiAgICAgdW5pdHM9InB4Ig0KICAgICBzaG93Z3VpZGVzPSJ0cnVlIg0KICAgICBvYmplY3R0b2xlcmFuY2U9IjIwIg0KICAgICBncmlkdG9sZXJhbmNlPSI1Ig0KICAgICBpbmtzY2FwZTpzbmFwLWdyaWRzPSJmYWxzZSINCiAgICAgZml0LW1hcmdpbi10b3A9IjgiDQogICAgIGZpdC1tYXJnaW4tbGVmdD0iOCINCiAgICAgZml0LW1hcmdpbi1yaWdodD0iOCINCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjgiDQogICAgIGlua3NjYXBlOmd1aWRlLWJib3g9InRydWUiDQogICAgIGd1aWRldG9sZXJhbmNlPSI5Ig0KICAgICBpbmtzY2FwZTpzbmFwLXRvLWd1aWRlcz0idHJ1ZSINCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIg0KICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDE2Ig0KICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMCINCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI3Ig0KICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIj4NCiAgICA8aW5rc2NhcGU6Z3JpZA0KICAgICAgIHR5cGU9Inh5Z3JpZCINCiAgICAgICBpZD0iZ3JpZDM3MTMiDQogICAgICAgc3BhY2luZ3g9IjIuNjQ1ODMzNCINCiAgICAgICBzcGFjaW5neT0iMi42NDU4MzM0Ig0KICAgICAgIHNuYXB2aXNpYmxlZ3JpZGxpbmVzb25seT0iZmFsc2UiDQogICAgICAgZW1wc3BhY2luZz0iMyINCiAgICAgICBvcmlnaW54PSIwIg0KICAgICAgIG9yaWdpbnk9IjAiIC8+DQogICAgPHNvZGlwb2RpOmd1aWRlDQogICAgICAgcG9zaXRpb249IjEuMzI3MTYwMywyNC4yODY0NDgiDQogICAgICAgb3JpZW50YXRpb249IjEsMCINCiAgICAgICBpZD0iZ3VpZGU0NTM0Ig0KICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+DQogICAgPHNvZGlwb2RpOmd1aWRlDQogICAgICAgcG9zaXRpb249IjYuNjEyNDE1MywyMi4yNjM1NTIiDQogICAgICAgb3JpZW50YXRpb249IjEsMCINCiAgICAgICBpZD0iZ3VpZGU0NTM4Ig0KICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+DQogICAgPHNvZGlwb2RpOmd1aWRlDQogICAgICAgcG9zaXRpb249Ii0yLjAwNTM1NjcsMjIuNDg1NzIiDQogICAgICAgb3JpZW50YXRpb249IjAsMSINCiAgICAgICBpZD0iZ3VpZGU0NTQwIg0KICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+DQogICAgPHNvZGlwb2RpOmd1aWRlDQogICAgICAgcG9zaXRpb249Ii0xLjczNjMyODIsMTcuMTk3OTE3Ig0KICAgICAgIG9yaWVudGF0aW9uPSIwLDEiDQogICAgICAgaWQ9Imd1aWRlNDU0MiINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICAgIDxzb2RpcG9kaTpndWlkZQ0KICAgICAgIHBvc2l0aW9uPSItMS44MTkwMTA1LDE0LjU1MjA4NCINCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIg0KICAgICAgIGlkPSJndWlkZTQ1NDQiDQogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4NCiAgICA8c29kaXBvZGk6Z3VpZGUNCiAgICAgICBwb3NpdGlvbj0iLTEuMjg5ODQzOCw5LjI0Mzg4MDQiDQogICAgICAgb3JpZW50YXRpb249IjAsMSINCiAgICAgICBpZD0iZ3VpZGU0NTQ2Ig0KICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+DQogICAgPHNvZGlwb2RpOmd1aWRlDQogICAgICAgcG9zaXRpb249Ii0xLjQzODY3MTksNi42MTQ1ODM1Ig0KICAgICAgIG9yaWVudGF0aW9uPSIwLDEiDQogICAgICAgaWQ9Imd1aWRlNDU0OCINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICAgIDxzb2RpcG9kaTpndWlkZQ0KICAgICAgIHBvc2l0aW9uPSItMC45OTIxODc1MiwxLjI4OTg0MzgiDQogICAgICAgb3JpZW50YXRpb249IjAsMSINCiAgICAgICBpZD0iZ3VpZGU0NTUwIg0KICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+DQogICAgPHNvZGlwb2RpOmd1aWRlDQogICAgICAgcG9zaXRpb249Ii00LjMyNjQyNTUsMTEuOTAzNTE3Ig0KICAgICAgIG9yaWVudGF0aW9uPSIwLDEiDQogICAgICAgaWQ9Imd1aWRlNDU1MiINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICAgIDxzb2RpcG9kaTpndWlkZQ0KICAgICAgIHBvc2l0aW9uPSItMTIuNzMzMDczLDMwLjQyNzA4NCINCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIg0KICAgICAgIGlkPSJndWlkZTk0MSINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICAgIDxzb2RpcG9kaTpndWlkZQ0KICAgICAgIHBvc2l0aW9uPSItMTcuMDQ4NDU1LDI1LjE0MDA0MSINCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIg0KICAgICAgIGlkPSJndWlkZTk0OSINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICAgIDxzb2RpcG9kaTpndWlkZQ0KICAgICAgIHBvc2l0aW9uPSItNS45NjM0NTEzLDI4LjQzNzQ3OSINCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIg0KICAgICAgIGlkPSJndWlkZTk1OCINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICAgIDxzb2RpcG9kaTpndWlkZQ0KICAgICAgIHBvc2l0aW9uPSItNy4xNTYxNDE2LDI1Ljg0MTYyMyINCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIg0KICAgICAgIGlkPSJndWlkZTk2MCINCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPg0KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4NCiAgPG1ldGFkYXRhDQogICAgIGlkPSJtZXRhZGF0YTUiPg0KICAgIDxyZGY6UkRGPg0KICAgICAgPGNjOldvcmsNCiAgICAgICAgIHJkZjphYm91dD0iIj4NCiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+DQogICAgICAgIDxkYzp0eXBlDQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+DQogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPg0KICAgICAgICA8Y2M6bGljZW5zZQ0KICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLTMuMC50eHQiIC8+DQogICAgICA8L2NjOldvcms+DQogICAgPC9yZGY6UkRGPg0KICA8L21ldGFkYXRhPg0KICA8Zw0KICAgICBpbmtzY2FwZTpsYWJlbD0iQ2FscXVlIDEiDQogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiDQogICAgIGlkPSJsYXllcjEiDQogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTU2OTkzNCwtMjU5LjIyMzg0KSI+DQogICAgPGcNCiAgICAgICBpZD0iZzQ2NzAiDQogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44MzY0NzYyNiwwLDAsMC44MzMzMTMwNSwwLjM5MTczNTYzLDQ2LjUxNjg3NykiPg0KICAgICAgPHJlY3QNCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwtMC4zMzQ4MjQ5NywwLjk0MjI4MDM0LDAsMCkiDQogICAgICAgICByeT0iMC42NDczODQ3Ig0KICAgICAgICAgeT0iMjkyLjc5MjQ1Ig0KICAgICAgICAgeD0iOTkuNTI4MjA2Ig0KICAgICAgICAgaGVpZ2h0PSI2LjczODQxMjkiDQogICAgICAgICB3aWR0aD0iNC4wODE0MTcxIg0KICAgICAgICAgaWQ9InJlY3Q0NTMyIg0KICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yMzA0NjQ0NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgLz4NCiAgICAgIDxyZWN0DQogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsLTAuMzM0ODI0OTgsMC45NDIyODAzNCwwLDApIg0KICAgICAgICAgcnk9IjAuNTc0OTAwMjEiDQogICAgICAgICB5PSIyOTUuODk4NjgiDQogICAgICAgICB4PSI5OS41MjY0NTEiDQogICAgICAgICBoZWlnaHQ9IjMuNjMyMTU4OCINCiAgICAgICAgIHdpZHRoPSI0LjA4MzE2OTUiDQogICAgICAgICBpZD0icmVjdDQ1MzItMyINCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjMwNDY0NDQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIC8+DQogICAgPC9nPg0KICAgIDxyZWN0DQogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4xMDI0MDM2NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46YmV2ZWw7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBpZD0icmVjdDQ2MzMiDQogICAgICAgd2lkdGg9IjAuNTM2Nzk1OTciDQogICAgICAgaGVpZ2h0PSIzLjA3NzAxMTEiDQogICAgICAgeD0iODUuMDIwNTM4Ig0KICAgICAgIHk9IjI4MC42NDI3OSINCiAgICAgICByeT0iMC4yMDI3NTE2NSINCiAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsLTAuMjkxMTA5MDIsMC45NTY2ODk4OSwwLDApIg0KICAgICAgIHJ4PSIwLjI2ODM5Nzk5IiAvPg0KICAgIDxyZWN0DQogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4xNjc0MTY5NTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46YmV2ZWw7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBpZD0icmVjdDQ2MzkiDQogICAgICAgd2lkdGg9IjMuMzc3NTQ5NiINCiAgICAgICBoZWlnaHQ9IjAuMzMyMjE4MDIiDQogICAgICAgeD0iMS4wNTMyMzIxIg0KICAgICAgIHk9IjI3MS4zMzk2NiINCiAgICAgICByeT0iMC4xNjYxMDkwMSIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxODI3NDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBkPSJtIDEuMzE2MjM4LDI3MS42NDQyIGMgLTAuMjQ5MTYzNiwxLjI0NTgxIC0xLjIwNDI5MDI5LDIuMTMxNzIgLTEuMjA0MjkwMjksMi4xMzE3MiBsIDQuNTQwMzEyNzksMC4wMjc2IGMgMCwwIC0wLjU4ODMwMywtMS4zMTQ5NyAtMC40NDk4Nzg4LC0yLjIyODU5Ig0KICAgICAgIGlkPSJwYXRoNDY0MSINCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIg0KICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjYyIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBkPSJtIDEuNzczMDM3OCwyNzEuNjQ0MTkgYyAtMC4yMDc2MzYzLDAuOTc1ODkgLTAuNzI2NzI3LDEuNzcxODMgLTAuNzI2NzI3LDEuNzcxODMiDQogICAgICAgaWQ9InBhdGg0NjQzIg0KICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiDQogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBkPSJtIDIuMTY3NTQ2MiwyNzEuNjU4MDMgYyAtMC4xNjYxMDksMC45MDY2OCAtMC41Mzk4NTQyLDEuNzU3OTkgLTAuNTM5ODU0MiwxLjc1Nzk5Ig0KICAgICAgIGlkPSJwYXRoNDY0NSINCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIg0KICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+DQogICAgPHBhdGgNCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjIyMTQ3ODY3cHg7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgZD0ibSAyLjU3OTQyMzQsMjcxLjYzNzI2IGMgLTAuMTE3NjYwNiwwLjk1NTEzIC0wLjM4NzU4NzcsMS43Nzg3NiAtMC4zODc1ODc3LDEuNzc4NzYiDQogICAgICAgaWQ9InBhdGg0NjQ3Ig0KICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiDQogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBkPSJtIDIuOTc3Mjk2MywyNzEuNjUxMTIgYyAtMC4xNzMwMzAyLDEuMzI4ODcgLTAuMjA3NjM2MiwxLjc2NDkgLTAuMjA3NjM2MiwxLjc2NDkiDQogICAgICAgaWQ9InBhdGg0NjQ5Ig0KICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiDQogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBkPSJtIDMuMzYxMTk2MSwyNzEuNjY0OTYgYyAwLjAyMDc2NCwxLjA2NTg1IC0wLjAwNjkzLDEuNzUxMDYgLTAuMDA2OTMsMS43NTEwNiINCiAgICAgICBpZD0icGF0aDQ2NTEiDQogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCINCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yMjE0Nzg2N3B4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgIGQ9Im0gMy43MTc4OTczLDI3MS42NzE4OCBjIDAuMDIwNzY0LDAuODY1MTUgMC4yNjMwMDU5LDEuNzQ0MTQgMC4yNjMwMDU5LDEuNzQ0MTQiDQogICAgICAgaWQ9InBhdGg0NjUzIg0KICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiDQogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4NCiAgICA8ZWxsaXBzZQ0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMTk1NjU4NTY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBpZD0icGF0aDk1MSINCiAgICAgICBjeD0iMi40MzAzMzQxIg0KICAgICAgIGN5PSIyODcuMDA5OTUiDQogICAgICAgcng9IjIuNzgzNTY1MyINCiAgICAgICByeT0iMi44MjA4NDc1IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4xNTE0MDgzMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6MC40NTQyMjQ5NiwgMC4xNTE0MDgzMztzdHJva2UtZGFzaG9mZnNldDowLjE0Mjg3NDk5O3N0cm9rZS1vcGFjaXR5OjE7bWFya2VyLXN0YXJ0OnVybCgjQXJyb3cyTHN0YXJ0KTttYXJrZXItZW5kOnVybCgjQXJyb3cyTGVuZCkiDQogICAgICAgZD0iTSAwLjAyNjQ4MDEyLDI4Ny4wMDk5NSBIIDQuODM0MTg4MSINCiAgICAgICBpZD0icGF0aDc2OTMiDQogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4NCiAgICA8cmVjdA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMTU5O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowLjU0MDg1MDM3O3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgaWQ9InJlY3Q5NTQiDQogICAgICAgd2lkdGg9IjIuNjQyNjI3NSINCiAgICAgICBoZWlnaHQ9IjQuMDIyNDA1NiINCiAgICAgICB4PSIxLjEwOTAyMDQiDQogICAgICAgeT0iMjYxLjgxMTQiDQogICAgICAgcng9IjAuMzIwNjM1MzIiDQogICAgICAgcnk9IjAuMjQyMjExNTEiIC8+DQogICAgPHJlY3QNCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE1OTAwMDAxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDoyLjA0NDE1ODk0O3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgaWQ9InJlY3Q5NTYiDQogICAgICAgd2lkdGg9IjMuNTc4MDcwOSINCiAgICAgICBoZWlnaHQ9IjAuNTg0NjUyMTMiDQogICAgICAgeD0iMC42MDI3OTQ2NSINCiAgICAgICB5PSIyNjEuMjIzOTEiDQogICAgICAgcng9IjAuMzIwNjM1MzIiDQogICAgICAgcnk9IjAuMjQyMjExNTEiIC8+DQogICAgPHBhdGgNCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjA2NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgIGQ9Im0gMi4xMzMzOTMsMjYyLjUzNjM2IHYgMi41OTU4NiINCiAgICAgICBpZD0icGF0aDk2OCINCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4wNjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSINCiAgICAgICBkPSJtIDIuNzE0OTI1MiwyNjIuNTM2MzYgdiAyLjU5NTg2Ig0KICAgICAgIGlkPSJwYXRoOTY4LTYiDQogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMDY1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiDQogICAgICAgZD0ibSAxLjU1MTg2MDgsMjYyLjUzNjM2IHYgMi41OTU4NiINCiAgICAgICBpZD0icGF0aDk2OC03Ig0KICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+DQogICAgPHBhdGgNCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjA2NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIg0KICAgICAgIGQ9Im0gMy4yOTY0NTcyLDI2Mi41MzYzNiB2IDIuNTk1ODYiDQogICAgICAgaWQ9InBhdGg5NjgtNSINCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPg0KICA8L2c+DQo8L3N2Zz4NCg==\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","/**\r\n * @module helpers\r\n */\r\n\r\n/**\r\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\r\n *\r\n * @memberof helpers\r\n * @type {number}\r\n */\r\nexport let earthRadius = 6371008.8;\r\n\r\n/**\r\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport let factors = {\r\n    centimeters: earthRadius * 100,\r\n    centimetres: earthRadius * 100,\r\n    degrees: 180 / Math.PI, // See https://github.com/Turfjs/turf/issues/1406\r\n    feet: earthRadius * 3.28084,\r\n    inches: earthRadius * 39.370,\r\n    kilometers: earthRadius / 1000,\r\n    kilometres: earthRadius / 1000,\r\n    meters: earthRadius,\r\n    metres: earthRadius,\r\n    miles: earthRadius / 1609.344,\r\n    millimeters: earthRadius * 1000,\r\n    millimetres: earthRadius * 1000,\r\n    nauticalmiles: earthRadius / 1852,\r\n    radians: 1,\r\n    yards: earthRadius / 1.0936,\r\n};\r\n\r\n/**\r\n * Area of measurement factors based on 1 square meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport let areaFactors = {\r\n    acres: 0.000247105,\r\n    centimeters: 10000,\r\n    centimetres: 10000,\r\n    feet: 10.763910417,\r\n    inches: 1550.003100006,\r\n    kilometers: 0.000001,\r\n    kilometres: 0.000001,\r\n    meters: 1,\r\n    metres: 1,\r\n    miles: 3.86e-7,\r\n    millimeters: 1000000,\r\n    millimetres: 1000000,\r\n    yards: 1.195990046,\r\n};\r\n\r\n/**\r\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\r\n *\r\n * @name feature\r\n * @param {Geometry} geometry input geometry\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature} a GeoJSON Feature\r\n * @example\r\n * var geometry = {\r\n *   'type': 'Point',\r\n *   'coordinates': [110, 50]\r\n * };\r\n *\r\n * var feature = turf.feature(geometry);\r\n *\r\n * //=feature\r\n */\r\nexport function feature(geometry, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const feat = {type: 'Feature'};\r\n    if (options.id === 0 || options.id) { feat.id = options.id; }\r\n    if (options.bbox) { feat.bbox = options.bbox; }\r\n    feat.properties = properties || {};\r\n    feat.geometry = geometry;\r\n    return feat;\r\n}\r\n\r\n/**\r\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\r\n * For GeometryCollection type use `helpers.geometryCollection`\r\n *\r\n * @name geometry\r\n * @param {string} type Geometry Type\r\n * @param {Array<any>} coordinates Coordinates\r\n * @returns {Geometry} a GeoJSON Geometry\r\n * @example\r\n * var type = 'Point';\r\n * var coordinates = [110, 50];\r\n * var geometry = turf.geometry(type, coordinates);\r\n * // => geometry\r\n */\r\nexport function geometry(type, coordinates) {\r\n    switch (type) {\r\n    case 'Point': return point(coordinates).geometry;\r\n    case 'LineString': return lineString(coordinates).geometry;\r\n    case 'Polygon': return polygon(coordinates).geometry;\r\n    case 'MultiPoint': return multiPoint(coordinates).geometry;\r\n    case 'MultiLineString': return multiLineString(coordinates).geometry;\r\n    case 'MultiPolygon': return multiPolygon(coordinates).geometry;\r\n    default: throw new Error(type + ' is invalid');\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a {@link Point} {@link Feature} from a Position.\r\n *\r\n * @name point\r\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Point>} a Point feature\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n *\r\n * //=point\r\n */\r\nexport function point(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'Point',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\r\n *\r\n * @name points\r\n * @param {Array<Array<number>>} coordinates an array of Points\r\n * @param {Object} [properties={}] Translate these properties to each Feature\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Point>} Point Feature\r\n * @example\r\n * var points = turf.points([\r\n *   [-75, 39],\r\n *   [-80, 45],\r\n *   [-78, 50]\r\n * ]);\r\n *\r\n * //=points\r\n */\r\nexport function points(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    return featureCollection(coordinates.map((coords) => {\r\n        return point(coords, properties);\r\n    }), options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\r\n *\r\n * @name polygon\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Polygon>} Polygon Feature\r\n * @example\r\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\r\n *\r\n * //=polygon\r\n */\r\nexport function polygon(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    for (const ring of coordinates) {\r\n        if (ring.length < 4) {\r\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\r\n        }\r\n        for (let j = 0; j < ring[ring.length - 1].length; j++) {\r\n            // Check if first point of Polygon contains two numbers\r\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\r\n                throw new Error('First and last Position are not equivalent.');\r\n            }\r\n        }\r\n    }\r\n    const geom = {\r\n        type: 'Polygon',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\r\n *\r\n * @name polygons\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\r\n * @example\r\n * var polygons = turf.polygons([\r\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\r\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\r\n * ]);\r\n *\r\n * //=polygons\r\n */\r\nexport function polygons(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    return featureCollection(coordinates.map((coords) => {\r\n        return polygon(coords, properties);\r\n    }), options);\r\n}\r\n\r\n/**\r\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\r\n *\r\n * @name lineString\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<LineString>} LineString Feature\r\n * @example\r\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\r\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\r\n *\r\n * //=linestring1\r\n * //=linestring2\r\n */\r\nexport function lineString(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    if (coordinates.length < 2) { throw new Error('coordinates must be an array of two or more positions'); }\r\n    const geom = {\r\n        type: 'LineString',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\r\n *\r\n * @name lineStrings\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\r\n * @example\r\n * var linestrings = turf.lineStrings([\r\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\r\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\r\n * ]);\r\n *\r\n * //=linestrings\r\n */\r\nexport function lineStrings(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    return featureCollection(coordinates.map((coords) => {\r\n        return lineString(coords, properties);\r\n    }), options);\r\n}\r\n\r\n/**\r\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\r\n *\r\n * @name featureCollection\r\n * @param {Feature[]} features input features\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {FeatureCollection} FeatureCollection of Features\r\n * @example\r\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\r\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\r\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\r\n *\r\n * var collection = turf.featureCollection([\r\n *   locationA,\r\n *   locationB,\r\n *   locationC\r\n * ]);\r\n *\r\n * //=collection\r\n */\r\nexport function featureCollection(features, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const fc = {type: 'FeatureCollection'};\r\n    if (options.id) { fc.id = options.id; }\r\n    if (options.bbox) { fc.bbox = options.bbox; }\r\n    fc.features = features;\r\n    return fc;\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<MultiLineString>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiLineString\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiLineString>} a MultiLineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\r\n *\r\n * //=multiLine\r\n */\r\nexport function multiLineString(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'MultiLineString',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<MultiPoint>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPoint\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPoint>} a MultiPoint feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\r\n *\r\n * //=multiPt\r\n */\r\nexport function multiPoint(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'MultiPoint',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<MultiPolygon>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPolygon\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPolygon>} a multipolygon feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\r\n *\r\n * //=multiPoly\r\n *\r\n */\r\nexport function multiPolygon(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'MultiPolygon',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<GeometryCollection>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name geometryCollection\r\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\r\n * @example\r\n * var pt = turf.geometry('Point', [100, 0]);\r\n * var line = turf.geometry('LineString', [[101, 0], [102, 1]]);\r\n * var collection = turf.geometryCollection([pt, line]);\r\n *\r\n * // => collection\r\n */\r\nexport function geometryCollection(geometries, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'GeometryCollection',\r\n        geometries,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Round number to precision\r\n *\r\n * @param {number} num Number\r\n * @param {number} [precision=0] Precision\r\n * @returns {number} rounded number\r\n * @example\r\n * turf.round(120.4321)\r\n * //=120\r\n *\r\n * turf.round(120.4321, 2)\r\n * //=120.43\r\n */\r\nexport function round(num, precision) {\r\n    if (precision && !(precision >= 0)) { throw new Error('precision must be a positive number'); }\r\n    const multiplier = Math.pow(10, precision || 0);\r\n    return Math.round(num * multiplier) / multiplier;\r\n}\r\n\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name radiansToLength\r\n * @param {number} radians in radians across the sphere\r\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} distance\r\n */\r\nexport function radiansToLength(radians, units) {\r\n    if (radians === undefined || radians === null) throw new Error('radians is required');\r\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\r\n\r\n    var factor = factors[units || 'kilometers'];\r\n    if (!factor) { throw new Error(units + ' units is invalid'); }\r\n    return radians * factor;\r\n}\r\n\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name lengthToRadians\r\n * @param {number} distance in real units\r\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} radians\r\n */\r\nexport function lengthToRadians(distance, units) {\r\n    if (distance === undefined || distance === null) throw new Error('distance is required');\r\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\r\n\r\n    var factor = factors[units || 'kilometers'];\r\n    if (!factor) { throw new Error(units + ' units is invalid'); }\r\n    return distance / factor;\r\n}\r\n\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\r\n *\r\n * @name lengthToDegrees\r\n * @param {number} distance in real units\r\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} degrees\r\n */\r\nexport function lengthToDegrees(distance, units) {\r\n    if (units === null) units = 'kilometers';\r\n    return radiansToDegrees(lengthToRadians(distance, units));\r\n}\r\n\r\n/**\r\n * Converts any bearing angle from the north line direction (positive clockwise)\r\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\r\n *\r\n * @name bearingToAzimuth\r\n * @param {number} bearing angle, between -180 and +180 degrees\r\n * @returns {number} angle between 0 and 360 degrees\r\n */\r\nexport function bearingToAzimuth(bearing) {\r\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\r\n\r\n    let angle = bearing % 360;\r\n    if (angle < 0) { angle += 360; }\r\n    return angle;\r\n}\r\n\r\n/**\r\n * Converts an angle in radians to degrees\r\n *\r\n * @name radiansToDegrees\r\n * @param {number} radians angle in radians\r\n * @returns {number} degrees between 0 and 360 degrees\r\n */\r\nexport function radiansToDegrees(radians) {\r\n    if (radians === null || radians === undefined) throw new Error('radians is required');\r\n\r\n    const degrees = radians % (2 * Math.PI);\r\n    return degrees * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts an angle in degrees to radians\r\n *\r\n * @name degreesToRadians\r\n * @param {number} degrees angle between 0 and 360 degrees\r\n * @returns {number} angle in radians\r\n */\r\nexport function degreesToRadians(degrees) {\r\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\r\n\r\n    const radians = degrees % 360;\r\n    return radians * Math.PI / 180;\r\n}\r\n\r\n/**\r\n * Converts a length to the requested unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @param {number} length to be converted\r\n * @param {Units} [originalUnit='kilometers'] of the length\r\n * @param {Units} [finalUnit='kilometers'] returned unit\r\n * @returns {number} the converted length\r\n */\r\nexport function convertLength(length, originalUnit, finalUnit) {\r\n    if (length === null || length === undefined) throw new Error('length is required');\r\n\r\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\r\n}\r\n\r\n/**\r\n * Converts a area to the requested unit.\r\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\r\n * @param {number} area to be converted\r\n * @param {Units} [originalUnit='meters'] of the distance\r\n * @param {Units} [finalUnit='kilometers'] returned unit\r\n * @returns {number} the converted distance\r\n */\r\nexport function convertArea(area, originalUnit, finalUnit) {\r\n    if (area === null || area === undefined) throw new Error('area is required');\r\n    if (!(area >= 0)) throw new Error('area must be a positive number');\r\n\r\n    var startFactor = areaFactors[originalUnit || 'meters'];\r\n    if (!startFactor) throw new Error('invalid original units');\r\n\r\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\r\n    if (!finalFactor) throw new Error('invalid final units');\r\n\r\n    return (area / startFactor) * finalFactor;\r\n}\r\n\r\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isNumber(123)\r\n * //=true\r\n * turf.isNumber('foo')\r\n * //=false\r\n */\r\nexport function isNumber(num) {\r\n    return !isNaN(num) && num !== null && !Array.isArray(num);\r\n}\r\n\r\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isObject({elevation: 10})\r\n * //=true\r\n * turf.isObject('foo')\r\n * //=false\r\n */\r\nexport function isObject(input) {\r\n    return (!!input) && (input.constructor === Object);\r\n}\r\n\r\n/**\r\n * Validate BBox\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox to validate\r\n * @returns {void}\r\n * @throws Error if BBox is not valid\r\n * @example\r\n * validateBBox([-180, -40, 110, 50])\r\n * //=OK\r\n * validateBBox([-180, -40])\r\n * //=Error\r\n * validateBBox('Foo')\r\n * //=Error\r\n * validateBBox(5)\r\n * //=Error\r\n * validateBBox(null)\r\n * //=Error\r\n * validateBBox(undefined)\r\n * //=Error\r\n */\r\nexport function validateBBox(bbox) {\r\n    if (!bbox) { throw new Error('bbox is required'); }\r\n    if (!Array.isArray(bbox)) { throw new Error('bbox must be an Array'); }\r\n    if (bbox.length !== 4 && bbox.length !== 6) { throw new Error('bbox must be an Array of 4 or 6 numbers'); }\r\n    bbox.forEach((num) => {\r\n        if (!isNumber(num)) { throw new Error('bbox must only contain numbers'); }\r\n    });\r\n}\r\n\r\n/**\r\n * Validate Id\r\n *\r\n * @private\r\n * @param {string|number} id Id to validate\r\n * @returns {void}\r\n * @throws Error if Id is not valid\r\n * @example\r\n * validateId([-180, -40, 110, 50])\r\n * //=Error\r\n * validateId([-180, -40])\r\n * //=Error\r\n * validateId('Foo')\r\n * //=OK\r\n * validateId(5)\r\n * //=OK\r\n * validateId(null)\r\n * //=Error\r\n * validateId(undefined)\r\n * //=Error\r\n */\r\nexport function validateId(id) {\r\n    if (!id) { throw new Error('id is required'); }\r\n    if (['string', 'number'].indexOf(typeof id) === -1) { throw new Error('id must be a number or a string'); }\r\n}\r\n\r\nexport function checkIfOptionsExist(options) {\r\n    options = options || {};\r\n    if (!isObject(options)) throw new Error('options is invalid');\r\n    return options;\r\n}\r\n\r\n// Deprecated methods\r\nexport function radians2degrees() {\r\n    throw new Error('method has been renamed to `radiansToDegrees`');\r\n}\r\n\r\nexport function degrees2radians() {\r\n    throw new Error('method has been renamed to `degreesToRadians`');\r\n}\r\n\r\nexport function distanceToDegrees() {\r\n    throw new Error('method has been renamed to `lengthToDegrees`');\r\n}\r\n\r\nexport function distanceToRadians() {\r\n    throw new Error('method has been renamed to `lengthToRadians`');\r\n}\r\n\r\nexport function radiansToDistance() {\r\n    throw new Error('method has been renamed to `radiansToLength`');\r\n}\r\n\r\nexport function bearingToAngle() {\r\n    throw new Error('method has been renamed to `bearingToAzimuth`');\r\n}\r\n\r\nexport function convertDistance() {\r\n    throw new Error('method has been renamed to `convertLength`');\r\n}\r\n","import { isNumber } from '../helpers';\r\n\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nexport function getCoord(coord) {\r\n    if (!coord) { throw new Error('coord is required'); }\r\n\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === 'Point') {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n\r\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\r\n}\r\n\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nexport function getCoords(coords) {\r\n    if (Array.isArray(coords)) { return coords; }\r\n\r\n    // Feature\r\n    if (coords.type === 'Feature') {\r\n        if (coords.geometry !== null) { return coords.geometry.coordinates; }\r\n    } else {\r\n        // Geometry\r\n        if (coords.coordinates) { return coords.coordinates; }\r\n    }\r\n\r\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\r\n}\r\n\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nexport function containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error('coordinates must only contain numbers');\r\n}\r\n\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nexport function geojsonType(value, type, name) {\r\n    if (!type || !name) { throw new Error('type and name required'); }\r\n\r\n    if (!value || value.type !== type) {\r\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\r\n    }\r\n}\r\n\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nexport function featureOf(feature, type, name) {\r\n    if (!feature) { throw new Error('No feature passed'); }\r\n    if (!name) { throw new Error('.featureOf() requires a name'); }\r\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\r\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\r\n    }\r\n}\r\n\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nexport function collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) { throw new Error('No featureCollection passed'); }\r\n    if (!name) { throw new Error('.collectionOf() requires a name'); }\r\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\r\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\r\n    }\r\n    for (const feature of featureCollection.features) {\r\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\r\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   'type': 'Feature',\r\n *   'properties': {},\r\n *   'geometry': {\r\n *     'type': 'Point',\r\n *     'coordinates': [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={'type': 'Point', 'coordinates': [110, 40]}\r\n */\r\nexport function getGeom(geojson){\r\n    if (geojson.type === 'Feature') { return geojson.geometry; }\r\n    return geojson;\r\n}\r\n\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name='geojson'] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   'type': 'Feature',\r\n *   'properties': {},\r\n *   'geometry': {\r\n *     'type': 'Point',\r\n *     'coordinates': [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //='Point'\r\n */\r\nexport function getType(geojson, name) {\r\n    if (geojson.type === 'FeatureCollection') { return 'FeatureCollection'; }\r\n    if (geojson.type === 'GeometryCollection') { return 'GeometryCollection'; }\r\n    if (geojson.type === 'Feature' && geojson.geometry !== null) { return geojson.geometry.type; }\r\n    return geojson.type;\r\n}\r\n","// http://en.wikipedia.org/wiki/Haversine_formula\r\n// http://www.movable-type.co.uk/scripts/latlong.html\r\nimport { degreesToRadians, radiansToDegrees, lengthToRadians, point, checkIfOptionsExist } from '../helpers';\r\nimport { getCoord } from '../invariant';\r\n\r\n/**\r\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\r\n * degrees, radians, miles, or kilometers; and bearing in degrees.\r\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\r\n *\r\n * @name destination\r\n * @param {Coord} origin starting point\r\n * @param {number} distance distance from the origin point\r\n * @param {number} bearing ranging from -180 to 180\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\r\n * @param {Object} [options.properties={}] Translate properties to Point\r\n * @returns {Feature<Point>} destination point\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n * var distance = 50;\r\n * var bearing = 90;\r\n * var options = {units: 'miles'};\r\n *\r\n * var destination = turf.destination(point, distance, bearing, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [point, destination]\r\n * destination.properties['marker-color'] = '#f00';\r\n * point.properties['marker-color'] = '#0f0';\r\n */\r\nexport default function destination(origin, distance, bearing, options) {\r\n\r\n    options = checkIfOptionsExist(options);\r\n    // Handle input\r\n    const coordinates1 = getCoord(origin);\r\n    const longitude1 = degreesToRadians(coordinates1[0]);\r\n    const latitude1 = degreesToRadians(coordinates1[1]);\r\n    const bearingRad = degreesToRadians(bearing);\r\n    const radians = lengthToRadians(distance, options.units);\r\n\r\n    // Main\r\n    const latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\r\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\r\n    const longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\r\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\r\n    const lng = radiansToDegrees(longitude2);\r\n    const lat = radiansToDegrees(latitude2);\r\n\r\n    return point([lng, lat], options.properties);\r\n}\r\n","import destination from '../destination';\r\nimport { polygon, checkIfOptionsExist } from '../helpers';\r\n\r\n/**\r\n * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\r\n *\r\n * @name circle\r\n * @param {Feature<Point>|number[]} center center point\r\n * @param {number} radius radius of the circle\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.steps=64] number of steps\r\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\r\n * @param {Object} [options.properties={}] properties\r\n * @returns {Feature<Polygon>} circle polygon\r\n * @example\r\n * var center = [-75.343, 39.984];\r\n * var radius = 5;\r\n * var options = {steps, units, properties{foo, radius, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [turf.point(center), circle]\r\n */\r\nfunction circle(center, radius, options) {\r\n    options = checkIfOptionsExist(options);\r\n    // default params\r\n    const steps = options.steps || 64;\r\n    const properties = options.properties ? options.properties : (!Array.isArray(center) && center.type === 'Feature' && center.properties) ? center.properties : {};\r\n\r\n    // main\r\n    const coordinates = [];\r\n    for (let i = 0; i < steps; i++) {\r\n        coordinates.push(destination(center, radius, i * -360 / steps, options).geometry.coordinates);\r\n    }\r\n    coordinates.push(coordinates[0]);\r\n\r\n    return polygon([coordinates], properties);\r\n}\r\n\r\nexport default circle;\r\n","import { feature, point, lineString, isObject } from '../helpers';\r\n\r\n/**\r\n * Callback for coordEach\r\n *\r\n * @callback coordEachCallback\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nexport function coordEach(geojson, callback, excludeWrapCoord) {\r\n    // Handles null Geometry -- Skips this GeoJSON\r\n    if (geojson === null) return;\r\n    var j, k, l, geometry, stopG, coords,\r\n        geometryMaybeCollection,\r\n        wrapShrink = 0,\r\n        coordIndex = 0,\r\n        isGeometryCollection,\r\n        type = geojson.type,\r\n        isFeatureCollection = type === 'FeatureCollection',\r\n        isFeature = type === 'Feature',\r\n        stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n    // This logic may look a little weird. The reason why it is that way\r\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n    // of objects at its root: FeatureCollection, Features, Geometries.\r\n    // This function has the responsibility of handling all of them, and that\r\n    // means that some of the `for` loops you see below actually just don't apply\r\n    // to certain inputs. For instance, if you give this just a\r\n    // Point geometry, then both loops are short-circuited and all we do\r\n    // is gradually rename the input until it's called 'geometry'.\r\n    //\r\n    // This also aims to allocate as few resources as possible: just a\r\n    // few numbers and booleans, rather than any temporary arrays as would\r\n    // be required with the normalization approach.\r\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\r\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\r\n            (isFeature ? geojson.geometry : geojson));\r\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\r\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\r\n\r\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\r\n            var multiFeatureIndex = 0;\r\n            var geometryIndex = 0;\r\n            geometry = isGeometryCollection ?\r\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\r\n\r\n            // Handles null Geometry -- Skips this geometry\r\n            if (geometry === null) continue;\r\n            coords = geometry.coordinates;\r\n            var geomType = geometry.type;\r\n\r\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\r\n\r\n            switch (geomType) {\r\n            case null:\r\n                break;\r\n            case 'Point':\r\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                coordIndex++;\r\n                multiFeatureIndex++;\r\n                break;\r\n            case 'LineString':\r\n            case 'MultiPoint':\r\n                for (j = 0; j < coords.length; j++) {\r\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                    coordIndex++;\r\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\r\n                }\r\n                if (geomType === 'LineString') multiFeatureIndex++;\r\n                break;\r\n            case 'Polygon':\r\n            case 'MultiLineString':\r\n                for (j = 0; j < coords.length; j++) {\r\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\r\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                        coordIndex++;\r\n                    }\r\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\r\n                    if (geomType === 'Polygon') geometryIndex++;\r\n                }\r\n                if (geomType === 'Polygon') multiFeatureIndex++;\r\n                break;\r\n            case 'MultiPolygon':\r\n                for (j = 0; j < coords.length; j++) {\r\n                    geometryIndex = 0;\r\n                    for (k = 0; k < coords[j].length; k++) {\r\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\r\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                            coordIndex++;\r\n                        }\r\n                        geometryIndex++;\r\n                    }\r\n                    multiFeatureIndex++;\r\n                }\r\n                break;\r\n            case 'GeometryCollection':\r\n                for (j = 0; j < geometry.geometries.length; j++)\r\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\r\n                break;\r\n            default:\r\n                throw new Error('Unknown Geometry Type');\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Callback for coordReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback coordReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\r\n *\r\n * @name coordReduce\r\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentCoord;\r\n * });\r\n */\r\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\r\n    var previousValue = initialValue;\r\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\r\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\r\n    }, excludeWrapCoord);\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for propEach\r\n *\r\n * @callback propEachCallback\r\n * @param {Object} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name propEach\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propEach(features, function (currentProperties, featureIndex) {\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n * });\r\n */\r\nexport function propEach(geojson, callback) {\r\n    var i;\r\n    switch (geojson.type) {\r\n    case 'FeatureCollection':\r\n        for (i = 0; i < geojson.features.length; i++) {\r\n            if (callback(geojson.features[i].properties, i) === false) break;\r\n        }\r\n        break;\r\n    case 'Feature':\r\n        callback(geojson.properties, 0);\r\n        break;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Callback for propReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback propReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {*} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce properties in any GeoJSON object into a single value,\r\n * similar to how Array.reduce works. However, in this case we lazily run\r\n * the reduction, so an array of all properties is unnecessary.\r\n *\r\n * @name propReduce\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n *   return currentProperties\r\n * });\r\n */\r\nexport function propReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    propEach(geojson, function (currentProperties, featureIndex) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\r\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for featureEach\r\n *\r\n * @callback featureEachCallback\r\n * @param {Feature<any>} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name featureEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.featureEach(features, function (currentFeature, featureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n * });\r\n */\r\nexport function featureEach(geojson, callback) {\r\n    if (geojson.type === 'Feature') {\r\n        callback(geojson, 0);\r\n    } else if (geojson.type === 'FeatureCollection') {\r\n        for (var i = 0; i < geojson.features.length; i++) {\r\n            if (callback(geojson.features[i], i) === false) break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Callback for featureReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback featureReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name featureReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nexport function featureReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    featureEach(geojson, function (currentFeature, featureIndex) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\r\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Get all coordinates from any GeoJSON object.\r\n *\r\n * @name coordAll\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @returns {Array<Array<number>>} coordinate position array\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * var coords = turf.coordAll(features);\r\n * //= [[26, 37], [36, 53]]\r\n */\r\nexport function coordAll(geojson) {\r\n    var coords = [];\r\n    coordEach(geojson, function (coord) {\r\n        coords.push(coord);\r\n    });\r\n    return coords;\r\n}\r\n\r\n/**\r\n * Callback for geomEach\r\n *\r\n * @callback geomEachCallback\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name geomEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n * });\r\n */\r\nexport function geomEach(geojson, callback) {\r\n    var i, j, g, geometry, stopG,\r\n        geometryMaybeCollection,\r\n        isGeometryCollection,\r\n        featureProperties,\r\n        featureBBox,\r\n        featureId,\r\n        featureIndex = 0,\r\n        isFeatureCollection = geojson.type === 'FeatureCollection',\r\n        isFeature = geojson.type === 'Feature',\r\n        stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n    // This logic may look a little weird. The reason why it is that way\r\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n    // of objects at its root: FeatureCollection, Features, Geometries.\r\n    // This function has the responsibility of handling all of them, and that\r\n    // means that some of the `for` loops you see below actually just don't apply\r\n    // to certain inputs. For instance, if you give this just a\r\n    // Point geometry, then both loops are short-circuited and all we do\r\n    // is gradually rename the input until it's called 'geometry'.\r\n    //\r\n    // This also aims to allocate as few resources as possible: just a\r\n    // few numbers and booleans, rather than any temporary arrays as would\r\n    // be required with the normalization approach.\r\n    for (i = 0; i < stop; i++) {\r\n\r\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\r\n            (isFeature ? geojson.geometry : geojson));\r\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\r\n            (isFeature ? geojson.properties : {}));\r\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\r\n            (isFeature ? geojson.bbox : undefined));\r\n        featureId = (isFeatureCollection ? geojson.features[i].id :\r\n            (isFeature ? geojson.id : undefined));\r\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\r\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\r\n\r\n        for (g = 0; g < stopG; g++) {\r\n            geometry = isGeometryCollection ?\r\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\r\n\r\n            // Handle null Geometry\r\n            if (geometry === null) {\r\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\r\n                continue;\r\n            }\r\n            switch (geometry.type) {\r\n            case 'Point':\r\n            case 'LineString':\r\n            case 'MultiPoint':\r\n            case 'Polygon':\r\n            case 'MultiLineString':\r\n            case 'MultiPolygon': {\r\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\r\n                break;\r\n            }\r\n            case 'GeometryCollection': {\r\n                for (j = 0; j < geometry.geometries.length; j++) {\r\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                throw new Error('Unknown Geometry Type');\r\n            }\r\n        }\r\n        // Only increase `featureIndex` per each feature\r\n        featureIndex++;\r\n    }\r\n}\r\n\r\n/**\r\n * Callback for geomReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback geomReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name geomReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=previousValue\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n *   return currentGeometry\r\n * });\r\n */\r\nexport function geomReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\r\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for flattenEach\r\n *\r\n * @callback flattenEachCallback\r\n * @param {Feature} currentFeature The current flattened feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over flattened features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name flattenEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n * });\r\n */\r\nexport function flattenEach(geojson, callback) {\r\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\r\n        // Callback for single geometry\r\n        var type = (geometry === null) ? null : geometry.type;\r\n        switch (type) {\r\n        case null:\r\n        case 'Point':\r\n        case 'LineString':\r\n        case 'Polygon':\r\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\r\n            return;\r\n        }\r\n\r\n        var geomType;\r\n\r\n        // Callback for multi-geometry\r\n        switch (type) {\r\n        case 'MultiPoint':\r\n            geomType = 'Point';\r\n            break;\r\n        case 'MultiLineString':\r\n            geomType = 'LineString';\r\n            break;\r\n        case 'MultiPolygon':\r\n            geomType = 'Polygon';\r\n            break;\r\n        }\r\n\r\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\r\n            var coordinate = geometry.coordinates[multiFeatureIndex];\r\n            var geom = {\r\n                type: geomType,\r\n                coordinates: coordinate\r\n            };\r\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Callback for flattenReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback flattenReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name flattenReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nexport function flattenReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\r\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for segmentEach\r\n *\r\n * @callback segmentEachCallback\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //=currentSegment\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   //=segmentIndex\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var total = 0;\r\n * turf.segmentEach(polygon, function () {\r\n *     total++;\r\n * });\r\n */\r\nexport function segmentEach(geojson, callback) {\r\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n        var segmentIndex = 0;\r\n\r\n        // Exclude null Geometries\r\n        if (!feature.geometry) return;\r\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n        var type = feature.geometry.type;\r\n        if (type === 'Point' || type === 'MultiPoint') return;\r\n\r\n        // Generate 2-vertex line segments\r\n        var previousCoords;\r\n        var previousFeatureIndex = 0;\r\n        var previousMultiIndex = 0;\r\n        var prevGeomIndex = 0;\r\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\r\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\r\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\r\n                previousCoords = currentCoord;\r\n                previousFeatureIndex = featureIndex;\r\n                previousMultiIndex = multiPartIndexCoord;\r\n                prevGeomIndex = geometryIndex;\r\n                segmentIndex = 0;\r\n                return;\r\n            }\r\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\r\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\r\n            segmentIndex++;\r\n            previousCoords = currentCoord;\r\n        }) === false) return false;\r\n    });\r\n}\r\n\r\n/**\r\n * Callback for segmentReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback segmentReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n */\r\n\r\n/**\r\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //= previousSegment\r\n *   //= currentSegment\r\n *   //= featureIndex\r\n *   //= multiFeatureIndex\r\n *   //= geometryIndex\r\n *   //= segmentInex\r\n *   return currentSegment\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var initialValue = 0\r\n * var total = turf.segmentReduce(polygon, function (previousValue) {\r\n *     previousValue++;\r\n *     return previousValue;\r\n * }, initialValue);\r\n */\r\nexport function segmentReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    var started = false;\r\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\r\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\r\n        started = true;\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for lineEach\r\n *\r\n * @callback lineEachCallback\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\r\n * similar to Array.forEach.\r\n *\r\n * @name lineEach\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *   [[26, 37], [35, 45]],\r\n *   [[36, 53], [38, 50], [41, 55]]\r\n * ]);\r\n *\r\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nexport function lineEach(geojson, callback) {\r\n    // validation\r\n    if (!geojson) throw new Error('geojson is required');\r\n\r\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n        if (feature.geometry === null) return;\r\n        var type = feature.geometry.type;\r\n        var coords = feature.geometry.coordinates;\r\n        switch (type) {\r\n        case 'LineString':\r\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\r\n            break;\r\n        case 'Polygon':\r\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\r\n                if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n            }\r\n            break;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Callback for lineReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback lineReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name lineReduce\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var multiPoly = turf.multiPolygon([\r\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\r\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\r\n * ]);\r\n *\r\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentLine\r\n * });\r\n */\r\nexport function lineReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\r\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `../meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n * Point & MultiPoint will always return null.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.segmentIndex=0] Segment Index\r\n * @param {Object} [options.properties={}] Translate Properties to output LineString\r\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\r\n * @param {number|string} [options.id={}] Translate Id to output LineString\r\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findSegment(multiLine);\r\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\r\n *\r\n * // First Segment of 2nd Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\r\n *\r\n * // Last Segment of Last Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\r\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\r\n */\r\nexport function findSegment(geojson, options) {\r\n    // Optional Parameters\r\n    options = options || {};\r\n    if (!isObject(options)) throw new Error('options is invalid');\r\n    var featureIndex = options.featureIndex || 0;\r\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n    var geometryIndex = options.geometryIndex || 0;\r\n    var segmentIndex = options.segmentIndex || 0;\r\n\r\n    // Find FeatureIndex\r\n    var properties = options.properties;\r\n    var geometry;\r\n\r\n    switch (geojson.type) {\r\n    case 'FeatureCollection':\r\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\r\n        properties = properties || geojson.features[featureIndex].properties;\r\n        geometry = geojson.features[featureIndex].geometry;\r\n        break;\r\n    case 'Feature':\r\n        properties = properties || geojson.properties;\r\n        geometry = geojson.geometry;\r\n        break;\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n        return null;\r\n    case 'LineString':\r\n    case 'Polygon':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n        geometry = geojson;\r\n        break;\r\n    default:\r\n        throw new Error('geojson is invalid');\r\n    }\r\n\r\n    // Find SegmentIndex\r\n    if (geometry === null) return null;\r\n    var coords = geometry.coordinates;\r\n    switch (geometry.type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n        return null;\r\n    case 'LineString':\r\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\r\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\r\n    case 'Polygon':\r\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\r\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\r\n    case 'MultiLineString':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\r\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\r\n    case 'MultiPolygon':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\r\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\r\n    }\r\n    throw new Error('geojson is invalid');\r\n}\r\n\r\n/**\r\n * Finds a particular Point from a GeoJSON using `../meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.coordIndex=0] Coord Index\r\n * @param {Object} [options.properties={}] Translate Properties to output Point\r\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\r\n * @param {number|string} [options.id={}] Translate Id to output Point\r\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findPoint(multiLine);\r\n * // => Feature<Point<[10, 10]>>\r\n *\r\n * // First Segment of the 2nd Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<Point<[-10, -10]>>\r\n *\r\n * // Last Segment of last Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\r\n * // => Feature<Point<[-30, -40]>>\r\n */\r\nexport function findPoint(geojson, options) {\r\n    // Optional Parameters\r\n    options = options || {};\r\n    if (!isObject(options)) throw new Error('options is invalid');\r\n    var featureIndex = options.featureIndex || 0;\r\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n    var geometryIndex = options.geometryIndex || 0;\r\n    var coordIndex = options.coordIndex || 0;\r\n\r\n    // Find FeatureIndex\r\n    var properties = options.properties;\r\n    var geometry;\r\n\r\n    switch (geojson.type) {\r\n    case 'FeatureCollection':\r\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\r\n        properties = properties || geojson.features[featureIndex].properties;\r\n        geometry = geojson.features[featureIndex].geometry;\r\n        break;\r\n    case 'Feature':\r\n        properties = properties || geojson.properties;\r\n        geometry = geojson.geometry;\r\n        break;\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n        return null;\r\n    case 'LineString':\r\n    case 'Polygon':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n        geometry = geojson;\r\n        break;\r\n    default:\r\n        throw new Error('geojson is invalid');\r\n    }\r\n\r\n    // Find Coord Index\r\n    if (geometry === null) return null;\r\n    var coords = geometry.coordinates;\r\n    switch (geometry.type) {\r\n    case 'Point':\r\n        return point(coords, properties, options);\r\n    case 'MultiPoint':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        return point(coords[multiFeatureIndex], properties, options);\r\n    case 'LineString':\r\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\r\n        return point(coords[coordIndex], properties, options);\r\n    case 'Polygon':\r\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\r\n        return point(coords[geometryIndex][coordIndex], properties, options);\r\n    case 'MultiLineString':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\r\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\r\n    case 'MultiPolygon':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\r\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\r\n    }\r\n    throw new Error('geojson is invalid');\r\n}\r\n","import circle from 'turf/src/circle';\r\nimport union from 'turf/src/union/';\r\nimport difference from 'turf/src/difference';\r\n\r\n\r\nlet turf = {\r\n\tcircle: circle,\r\n\tunion: union,\r\n\tdifference: difference\r\n};\r\n\r\nexport default turf;","import * as polyClipping from 'polygon-clipping';\r\nimport { multiPolygon } from '../helpers';\r\nimport { geomEach } from '../meta';\r\n\r\n/**\r\n * Takes two or more {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\r\n *\r\n * @name union\r\n * @param {Feature<Polygon|MultiPolygon>} fc a FeatureCollection containting polygons or multipolygons to union\r\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *     [-82.574787, 35.594087],\r\n *     [-82.574787, 35.615581],\r\n *     [-82.545261, 35.615581],\r\n *     [-82.545261, 35.594087],\r\n *     [-82.574787, 35.594087]\r\n * ]], {\"fill\": \"#0f0\"});\r\n * var poly2 = turf.polygon([[\r\n *     [-82.560024, 35.585153],\r\n *     [-82.560024, 35.602602],\r\n *     [-82.52964, 35.602602],\r\n *     [-82.52964, 35.585153],\r\n *     [-82.560024, 35.585153]\r\n * ]], {\"fill\": \"#00f\"});\r\n *\r\n * var union = turf.union(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, union];\r\n */\r\nfunction union(fc) {\r\n\r\n    const args = [];\r\n    geomEach(fc, function (geom) {\r\n        if (geom.type === 'Polygon') args.push(geom.coordinates);\r\n        else geom.coordinates.forEach(function (contour) {\r\n            args.push(contour);\r\n        });\r\n    });\r\n    var unioned = polyClipping.union(args);\r\n    if (unioned.length === 0) return null;\r\n    else return multiPolygon(unioned);\r\n}\r\n\r\nexport default union;\r\n","import * as polyClipping from 'polygon-clipping';\r\nimport {  multiPolygon } from '../helpers';\r\nimport { getGeom } from '../invariant';\r\n\r\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = getGeom(polygon1);\r\n    var geom2 = getGeom(polygon2);\r\n    var properties = polygon1.properties || {};\r\n    var differenced = polyClipping.difference(geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    return multiPolygon(differenced, properties);\r\n}\r\n\r\nexport default difference;\r\n","//import L from 'leaflet';\r\nimport turf from './myTurf.js';\r\nimport './PaintPolygon.css';\r\n\r\n\"use strict\";\r\n\r\n\r\nconst PaintPolygon = L.Control.extend({\r\n    options: {\r\n        position: 'topright',\r\n        radius: 30,\r\n        minRadius: 10,\r\n        maxRadius: 50,\r\n        layerOptions: {\r\n        },\r\n        drawOptions: {\r\n            weight: 1\r\n        },\r\n        eraseOptions: {\r\n            color: '#ff324a',\r\n            weight: 1\r\n        },\r\n        menu: {\r\n            drawErase: true,\r\n            size: true,\r\n            eraseAll: true\r\n        },\r\n    },\r\n\r\n    _latlng: [0, 0],\r\n    _metersPerPixel: {},\r\n\r\n    onAdd: function(map) {\r\n        this._map = map;\r\n        this.setRadius(this.options.radius);\r\n\r\n        if (this.options.menu === false) {\r\n            return L.DomUtil.create('div');\r\n        }\r\n\r\n        this._container = L.DomUtil.create('div', 'leaflet-control-paintpolygon leaflet-bar leaflet-control');\r\n        this._createMenu();\r\n\r\n        return this._container;\r\n    },\r\n\r\n    onRemove: function() {\r\n        this._map.off('mousemove', this._onMouseMove, this);\r\n    },\r\n\r\n    setRadius: function(radius) {\r\n        if (radius !== undefined) {\r\n            if (radius < this.options.minRadius) {\r\n                this._radius = this.options.minRadius;\r\n            } else if (radius > this.options.maxRadius) {\r\n                this._radius = this.options.maxRadius;\r\n            } else {\r\n                this._radius = radius;\r\n            }\r\n        }\r\n        if (this._circle) {\r\n            this._circle.setRadius(this._radius);\r\n        }\r\n    },\r\n    startDraw: function() {\r\n        this.stop();\r\n        this._action = 'draw';\r\n        this._addMouseListener();\r\n        this._circle = L.circleMarker(this._latlng, this.options.drawOptions).setRadius(this._radius).addTo(this._map);\r\n        console.log(this._circle);\r\n    },\r\n    startErase: function() {\r\n        this.stop();\r\n        this._action = 'erase';\r\n        this._addMouseListener();\r\n        this._circle = L.circleMarker(this._latlng, this.options.eraseOptions).setRadius(this._radius).addTo(this._map);\r\n    },\r\n    stop: function() {\r\n        this._action = null;\r\n        if (this._circle) {\r\n            this._circle.remove();\r\n        }\r\n        this._removeMouseListener();\r\n    },\r\n    getLayer: function() {\r\n        return this._layer;\r\n    },\r\n    setData: function(data) {\r\n        this._data = data;\r\n        if (this._layer !== undefined) {\r\n            this._layer.remove();\r\n        }\r\n        console.group('setData')\r\n        console.log(this._data, this.options)\r\n        this._layer = L.geoJSON(this._data, this.options.layerOptions).addTo(this._map);\r\n        console.groupEnd()\r\n    },\r\n    getData: function() {\r\n        return this._data;\r\n    },\r\n    eraseAll: function() {\r\n        this.setData();\r\n    },\r\n\r\n    /////////////////////////\r\n    // Menu creation and click callback\r\n    _createMenu: function() {\r\n        if (this.options.menu.drawErase !== false) {\r\n            this._iconDraw = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-brush', this._container);\r\n            this._iconErase = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-eraser', this._container);\r\n            L.DomEvent.on(this._iconDraw, 'click mousedown', this._clickDraw, this);\r\n            L.DomEvent.on(this._iconErase, 'click mousedown', this._clickErase, this);\r\n        }\r\n\r\n        if (this.options.menu.size !== false) {\r\n            this._iconSize = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-size', this._container);\r\n\r\n            this._menu = L.DomUtil.create('div', 'leaflet-bar leaflet-control-paintpolygon-menu', this._container);\r\n            L.DomEvent.disableClickPropagation(this._menu);\r\n\r\n            var menuContent = L.DomUtil.create('div', 'leaflet-control-paintpolygon-menu-content', this._menu);\r\n            var cursor = L.DomUtil.create('input', '', menuContent);\r\n            cursor.type = \"range\";\r\n            cursor.value = this._radius;\r\n            cursor.min = this.options.minRadius;\r\n            cursor.max = this.options.maxRadius;\r\n\r\n            L.DomEvent.on(cursor, 'input change', this._cursorMove, this);\r\n            L.DomEvent.on(this._iconSize, 'click mousedown', this._clickSize, this);\r\n        }\r\n\r\n        if (this.options.menu.eraseAll !== false) {\r\n            this._iconEraseAll = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-trash', this._container);\r\n            L.DomEvent.on(this._iconEraseAll, 'click mousedown', this._clickEraseAll, this);\r\n        }\r\n    },\r\n\r\n    _clickDraw: function(evt) {\r\n        if (evt.type == 'mousedown') {\r\n            L.DomEvent.stop(evt);\r\n            return;\r\n        }\r\n        this._resetMenu();\r\n        if (this._action == 'draw') {\r\n            this.stop();\r\n        } else {\r\n            this.startDraw();\r\n            this._activeIconStyle(this._iconDraw);\r\n        }\r\n    },\r\n    _clickErase: function(evt) {\r\n        if (evt.type == 'mousedown') {\r\n            L.DomEvent.stop(evt);\r\n            return;\r\n        }\r\n        this._resetMenu();\r\n        if (this._action == 'erase') {\r\n            this.stop();\r\n        } else {\r\n            this.startErase();\r\n            this._activeIconStyle(this._iconErase);\r\n        }\r\n    },\r\n    _clickSize: function(evt) {\r\n        if (evt.type == 'mousedown') {\r\n            L.DomEvent.stop(evt);\r\n            return;\r\n        }\r\n        if (L.DomUtil.hasClass(this._menu, 'leaflet-control-paintpolygon-menu-open')) {\r\n            this._closeMenu();\r\n        } else {\r\n            this._openMenu();\r\n        }\r\n    },\r\n    _clickEraseAll: function(evt) {\r\n        this.eraseAll();\r\n    },\r\n    _resetMenu: function() {\r\n        L.DomUtil.removeClass(this._iconDraw, \"leaflet-control-paintpolygon-icon-active\");\r\n        L.DomUtil.removeClass(this._iconErase, \"leaflet-control-paintpolygon-icon-active\");\r\n    },\r\n    _activeIconStyle: function(icon) {\r\n        L.DomUtil.addClass(icon, \"leaflet-control-paintpolygon-icon-active\");\r\n    },\r\n    _openMenu: function() {\r\n        L.DomUtil.addClass(this._menu, \"leaflet-control-paintpolygon-menu-open\");\r\n    },\r\n    _closeMenu: function() {\r\n        L.DomUtil.removeClass(this._menu, \"leaflet-control-paintpolygon-menu-open\");\r\n    },\r\n    _cursorMove: function(evt) {\r\n        this.setRadius(evt.target.valueAsNumber);\r\n    },\r\n    /////////////////\r\n\r\n\r\n\r\n    ////////////////\r\n    // Map events\r\n    _addMouseListener: function() {\r\n        this._map.on('mousemove', this._onMouseMove, this);\r\n        this._map.on('mousedown', this._onMouseDown, this);\r\n        this._map.on('mouseup', this._onMouseUp, this);\r\n    },\r\n    _removeMouseListener: function() {\r\n        this._map.off('mousemove', this._onMouseMove, this);\r\n        this._map.off('mousedown', this._onMouseDown, this);\r\n        this._map.off('mouseup', this._onMouseUp, this);\r\n    },\r\n    _onMouseDown: function(evt) {\r\n        this._map.dragging.disable();\r\n        this._mousedown = true;\r\n        this._onMouseMove(evt);\r\n    },\r\n    _onMouseUp: function(evt) {\r\n        this._map.dragging.enable();\r\n        this._mousedown = false;\r\n\r\n        console.group('debug');\r\n        console.log('map', this._map);\r\n        console.log('circle', this._circle);\r\n        console.log('stack', this._stack);\r\n        console.groupEnd();\r\n\r\n    },\r\n    _onMouseMove: function(evt) {\r\n        //console.log('_onMouseMove', evt);\r\n        this._setLatLng(evt.latlng);\r\n        if (this._mousedown === true) {\r\n            this._stackEvt(evt.latlng, this._map.getZoom(), this._radius, this._action);\r\n        }\r\n    },\r\n    ////////////////\r\n\r\n    _setLatLng: function(latlng) {\r\n        if (latlng !== undefined) {\r\n            this._latlng = latlng;\r\n        }\r\n        if (this._circle) {\r\n            this._circle.setLatLng(this._latlng);\r\n        }\r\n    },\r\n\r\n    _latLngAsGeoJSON: function(latlng) {\r\n        return {\r\n            type: \"Point\",\r\n            coordinates: [\r\n                latlng.lng,\r\n                latlng.lat\r\n            ]\r\n        };\r\n    },\r\n\r\n    _getCircleAsPolygon: function(latlng, zoom, radius) {\r\n        var lat = latlng.lat;\r\n\r\n        if (this._metersPerPixel[zoom] === undefined){\r\n            this._metersPerPixel[zoom] = 40075016.686 * Math.abs(Math.cos(lat * Math.PI / 180)) / Math.pow(2, zoom + 8);\r\n        }\r\n        return turf.circle(this._latLngAsGeoJSON(latlng), this._metersPerPixel[zoom] * radius / 1000, {\r\n            //steps: 128\r\n        });\r\n    },\r\n\r\n    _draw: function(latlng, zoom, radius) {\r\n        console.log({latlng, zoom, radius});\r\n        if (this._data === undefined || this._data === null) {\r\n            this.setData(this._getCircleAsPolygon(latlng, zoom, radius));\r\n        } else {\r\n            let fc = {\r\n                type: \"FeatureCollection\",\r\n                features:[this._data, this._getCircleAsPolygon(latlng, zoom, radius)]\r\n            };\r\n            this.setData(turf.union(fc));\r\n        }\r\n    },\r\n    _erase: function(latlng, zoom, radius) {\r\n        if (this._data === undefined || this._data === null) {\r\n            return;\r\n        } else {\r\n            this.setData(turf.difference(this._data, this._getCircleAsPolygon(latlng, zoom, radius)));\r\n        }\r\n    },\r\n\r\n    _stackEvt: function(latlng, zoom, radius, action) {\r\n        if (this._stack === undefined){\r\n            this._stack = new Array();\r\n        }\r\n\r\n        this._stack.push({latlng: latlng, zoom: zoom, radius: radius, action: action});\r\n        this._processStack();\r\n    },\r\n\r\n    _processStack: function() {\r\n        if (this._processingStack === true || this._stack.length == 0){\r\n            return;\r\n        }\r\n        this._processingStack = true;\r\n\r\n        var evt = this._stack.shift();\r\n        if (evt.action == \"draw\"){\r\n            this._draw(evt.latlng, evt.zoom, evt.radius);\r\n        } else if (evt.action == \"erase\") {\r\n            this._erase(evt.latlng, evt.zoom, evt.radius);\r\n        }\r\n\r\n        this._processingStack = false;\r\n        this._processStack();\r\n    }\r\n \r\n});\r\n\r\n\r\nL.Control.PaintPolygon = PaintPolygon;\r\nL.control.paintPolygon = options => new L.Control.PaintPolygon(options);\r\n\r\n\r\nexport default PaintPolygon;\r\n"],"sourceRoot":""}